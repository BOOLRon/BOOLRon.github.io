<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Ron's Blog]]></title>
  <link href="http://BOOLRon.github.io/atom.xml" rel="self"/>
  <link href="http://BOOLRon.github.io/"/>
  <updated>2016-03-06T18:48:46+08:00</updated>
  <id>http://BOOLRon.github.io/</id>
  <author>
    <name><![CDATA[Ron]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一个更具包容性的经济发展蓝图]]></title>
    <link href="http://BOOLRon.github.io/blog/2016/03/06/%5B%3F%5D-ge-geng-ju-bao-rong-xing-de-jing-ji-fa-zhan-lan-tu/"/>
    <updated>2016-03-06T18:44:17+08:00</updated>
    <id>http://BOOLRon.github.io/blog/2016/03/06/[?]-ge-geng-ju-bao-rong-xing-de-jing-ji-fa-zhan-lan-tu</id>
    <content type="html"><![CDATA[<p>哈佛商学院校友最近的一项调查发现，71%的受访者认为他们的生意受到了<code>不平等</code>，<code>中产阶级的停滞</code>，<code>日益增长的贫困</code>，或<code>有限的经济流动</code>的伤害。66%的受访者认为解决这些问题比促进经济发展重要。</p>

<p>尽管如此，许多雇主仍然觉得采取诸如改善工人和家庭的福祉的行动，是别人的工作。</p>

<p>这种心态是一个错误。商界领袖不只是雇主：作为区域经济发展实体的董事会成员，他们在城市和大都会地区的城市，他们的公司有重大影响。随着政府和非营利部门的合作伙伴，他们有能力转变和扩大经济发展的目的和实践。</p>

<p>在最近的一篇文章中，我提出了一个改善经济发展的框架，我认为，可持续的区域增长需要提高所有的生活水平。经济的包容性必须是经济决策者和企业的优先考虑。如果下一代的工人不准备满足主要雇主的需求，那将扼杀行业的生产力、扩张和剩余价值。如果人们失业或半失业，他们不能购买许多商品和服务的生产，伤害小企业和企业家。低效利用土地和基础设施-包括拥塞可以创造阻碍工作访问，限制了生产率的提高，和损害财产。</p>

<p>认识到促进经济包容的必要性是一件事，但做这件事是另一回事。在整个国家，一些企业和公民领袖正在为如何实现更具包容性的增长提供一个蓝图。这里有三个概念已经出现：</p>

<h3>确立一个明确的目标，并评估它</h3>

<p>促进经济包容性是以达成目标一致的。在<code>明尼阿波利斯-圣保罗</code>，不同的利益相关者从经济发展，慈善事业，企业，政府和社区的发展，共同达成共识，对经济，社会和环境的进步，这将引导他们的区域战略的50多个指标。确立一个基本目标后，他们解决了一个核心组合的指标来衡量创新，人才开发，就业准入，和工作质量，同时越来越多的关注基于种族的贫困与不平等。新的区域性仪表板包括指标，如“16至64岁的外国人口占总劳动人口百分比”和“白种人与其它种族人的就业差异”，如果各地区的利益相关者没能在一个地区达成一致的集体目标，并设法实现，则建设包容性经济将无从谈起。</p>

<h3>重点支持能提供良好的就业机会的行业</h3>

<p>不是所有的工作都是平等的。在美国每四个成年人，几乎就有一个人的工资难以维持正常生活，而国民经济中的低收入工作岗位却越来越多。根据国家就业法项目的报告，230万以上的工人受雇于低工资行业，而不是经济衰退的开始，而在中等收入和高工资行业就业的则少了120万。所有群体的经济活动开始于就业，它能使一个工人脱离贫困，做不到这样就无法减少种族差异、提高经济流动性。为提高包容性，领导者必须优先支持那些能提供较高人均收入、能维持家庭的工作岗位的产业。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何从640*1136的psd文件批量切出3x和2x的png]]></title>
    <link href="http://BOOLRon.github.io/blog/2014/10/19/ru-he-cong-640-star-1136de-psdwen-jian-pi-liang-qie-chu-3xhe-2xde-png/"/>
    <updated>2014-10-19T22:01:39+08:00</updated>
    <id>http://BOOLRon.github.io/blog/2014/10/19/ru-he-cong-640-star-1136de-psdwen-jian-pi-liang-qie-chu-3xhe-2xde-png</id>
    <content type="html"><![CDATA[<p>我们知道设计师给到的psd一般都按640*1136的分辨率来做的，这也不能怪他们，因为他们需要一边设计一边投射到iPhone上看效果，而用iPhone6 Plus的设计师不多，大部分都是4寸的iPhone。而我们需要@3x的图才能在iPhone6 Plus上有比较绚丽的效果，下面我就分享一下如果从psd批量切出@3x和2x的png。</p>

<p>首先设计师把psd扔给我说，“我很忙啊，自己切吧”，“哦”。</p>

<p>然后另外有朋友告诉我<a href="http://www.cutterman.cn/">cutterman</a>插件安装在PS后就可以切出@3x的图了，他说虽然暂时的版本不支持直接导出，但可以在Android模式下导出xxhdpi的图就是我们所需要@3x图的大小。</p>

<p>在比如说我们要批量导出几个按钮的icon，继续同时选中它们，然后设置好导出路径，点击[导出选中图层]，然后在设定的路径上会多好几个文件夹，其中<strong>drawable-xxhdpi</strong>文件夹里放的就是我们想要的@3x的图了，接着可以借助重明名工具批量添加@3x的后缀，最后全选@3x的png，一起拖进<a href="http://testzone.qiniudn.com/gandou3xExporter.app.zip">甘豆3xExporter</a>（一个批量将3x图导出成2x和1x的小工具）即可。</p>

<p>具体操作我录制了个<a href="http://testzone.qiniudn.com/%E5%A6%82%E4%BD%95%E4%BB%8E640*1136%E7%9A%84psd%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E5%88%87%E5%87%BA3x%E5%92%8C2x%E7%9A%84png.mov">小视频</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于大屏iPhone的适配]]></title>
    <link href="http://BOOLRon.github.io/blog/2014/09/10/sui-ran-gang-shang-shi-de-iphone6yu-ipgua-pei-bu-gong-zuo-liao-ma-%3F/"/>
    <updated>2014-09-10T21:41:27+08:00</updated>
    <id>http://BOOLRon.github.io/blog/2014/09/10/sui-ran-gang-shang-shi-de-iphone6yu-ipgua-pei-bu-gong-zuo-liao-ma-?</id>
    <content type="html"><![CDATA[<h3>背景</h3>

<p>话说昨晚苹果2014秋季发布会推出了iPhone6与iPhone6 Plus，作为开发者我最关心的当然是适配问题。</p>

<h3>应用运行在大屏上会变成怎样？</h3>

<p>我用Xcode 6 GM写个程序来实验一下，打算用UILabel来模拟长文本的显示情况，下面分别是iPhone5、iPhone6和iPhone6 Plus模拟器跑的效果：
<img src="http://gitlab.cngump.com/uploads/ganguo/wiki/3ecad5b747/iOS_Simulator_Screen_Shot_Sep_10__2014__10.12.46_PM.png" alt="iPhone5" /></p>

<hr />

<p><img src="http://gitlab.cngump.com/uploads/ganguo/wiki/7cb87524ab/iOS_Simulator_Screen_Shot_Sep_10__2014__9.34.00_PM.png" alt="iPhone6" /></p>

<hr />

<p><img src="http://gitlab.cngump.com/uploads/ganguo/wiki/5ec3a9f01e/iOS_Simulator_Screen_Shot_Sep_10__2014__10.11.59_PM.png" alt="iPhone6 Plus" /></p>

<hr />

<p>可以看出在大屏时，应用是被直接拉伸变大的。这样有个好处是对已经上架的App Store没什么影响（相信你也记得相当年iPhone5推出长屏幕时，旧应用跑起来上下留黑边了）</p>

<h3>但是</h3>

<p>单纯的放大就体现不了大屏幕的优势了，其实，我们只需要在LaunchImage里添加Retina HD的图就可以相当于开启适配大屏模式，只要我们的View里添加好所需要的约束（AutoLayout）就能很好的兼容到大屏幕了，</p>

<p><img src="http://gitlab.cngump.com/uploads/ganguo/wiki/ac4d4c9b45/Screen_Shot_2014-09-10_at_11.08.28_PM.png" alt="Screen Shot 2014-09-10 at 11.08.28 PM" /></p>

<hr />

<p>下图是兼容iPhone6后的效果：
<img src="http://gitlab.cngump.com/uploads/ganguo/wiki/a7e60e256a/iOS_Simulator_Screen_Shot_Sep_10__2014__11.14.39_PM.png" alt="iOS Simulator Screen Shot Sep 10, 2014, 11.14.39 PM" /></p>

<p>应用不再是硬梆梆的直接拉大，而是显示更多的内容，太棒了，以后用iPhone6 Plus一屏可以看更多微博了。</p>

<h3>最后</h3>

<p>最后推测一下：以后苹果有可能说提交App Store必须带Retina HD启动图，所以掌握AutoLayout是很必要的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[raywenderlich.com Swift风格指南]]></title>
    <link href="http://BOOLRon.github.io/blog/2014/09/08/raywenderlich-dot-com-swiftfeng-ge-zhi-nan/"/>
    <updated>2014-09-08T15:28:49+08:00</updated>
    <id>http://BOOLRon.github.io/blog/2014/09/08/raywenderlich-dot-com-swiftfeng-ge-zhi-nan</id>
    <content type="html"><![CDATA[<p>因为该指南关注于网页上以及打印版的可读性，所以它可能与你阅读过的指南有所不同。为了保证那些在我们书中、教程里以及初学者工程里的代码美观并且一致，我们写下了这份风格指南，尽管书由许多不同作者共同创作而成。</p>

<p>该指南的首要目标是让代码紧凑，可读性高且简洁。</p>

<h2>目录</h2>

<ul>
<li><a href="#%E8%AF%AD%E8%A8%80">语言</a></li>
<li><a href="#%E9%97%B4%E9%9A%94">间隔</a></li>
<li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
<li><a href="#%E5%91%BD%E5%90%8D">命名</a>

<ul>
<li><a href="#%E7%B1%BB%E5%89%8D%E7%BC%80">类前缀</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E5%8F%B7">分号</a></li>
<li><a href="#%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93">类与结构体</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E">函数声明</a></li>
<li><a href="#%E9%97%AD%E5%8C%85">闭包</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B">类型</a>

<ul>
<li><a href="#%E5%B8%B8%E9%87%8F">常量</a></li>
<li><a href="#Optional">Optional</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">类型推导</a></li>
<li><a href="#%E8%AF%AD%E6%B3%95%E7%B3%96">语法糖</a></li>
</ul>
</li>
<li><a href="#%E6%8E%A7%E5%88%B6%E6%B5%81">控制流</a></li>
<li><a href="#Self%E7%9A%84%E4%BD%BF%E7%94%A8">Self的使用</a></li>
<li><a href="#%E7%AC%91%E8%84%B8">笑脸</a></li>
<li><a href="#%E8%87%B4%E8%B0%A2">致谢</a></li>
</ul>


<h2>语言</h2>

<p>使用美式英语拼写以确保和苹果公司的API一致</p>

<p><strong>优选：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">var</span> <span class="n">color</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不建议使用：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">var</span> <span class="n">colour</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>间隔</h2>

<ul>
<li>使用2个空格而不是Tab进行缩进，可以减少换行。确保在Xcode的配置项中使用此设置。</li>
<li>方法的花括号以及其它花括号（<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code>等等）总是跟语句在同一行开始，新起一行结束。</li>
</ul>


<p><strong>优选：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">isHappy</span> <span class="p">{</span>
</span><span class='line'>  <span class="sr">//</span><span class="no">Do</span> <span class="n">something</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>  <span class="sr">//</span><span class="no">Do</span> <span class="n">something</span> <span class="k">else</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不建议使用：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">isHappy</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="sr">//</span><span class="no">Do</span> <span class="n">something</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="sr">//</span><span class="no">Do</span> <span class="n">something</span> <span class="k">else</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>方法之间应该总是用一个空行进行分隔以提高视觉以及结构上的清晰度。方法中的空白用来分开功能块，但是如果一个方法中存在太多功能块时，通常意味着你需要将它重构为多个方法。</li>
</ul>


<h2>注释</h2>

<ul>
<li><p>在需要的时候使用注释说明一块代码<strong>为什么</strong>这么做。注释必须时刻跟进代码，不然删了得了。</p></li>
<li><p>代码应该尽可能的自文档化，避免在代码中使用成块的注释。<strong>例外：该规则不适用与用于生成文档的块注释。</strong></p></li>
</ul>


<h2>命名</h2>

<p>使用驼峰法为类、方法、变量等取一个描述性强的名字。模块范围的类名和常量名以大写字母开头，而方法名和变量名应以小写字母开头。</p>

<p><strong>优选：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">let</span> <span class="no">MaximumWidgetCount</span> <span class="o">=</span> <span class="mi">100</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">WidgetContainer</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">var</span> <span class="ss">widgetButton</span><span class="p">:</span> <span class="no">UIButton</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">widgetHeightPercentage</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">85</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不建议使用：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">let</span> <span class="no">MAX_WIDGET_COUNT</span> <span class="o">=</span> <span class="mi">100</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="n">app_widgetContainer</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">var</span> <span class="ss">wBut</span><span class="p">:</span> <span class="no">UIButton</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">wHeightPct</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">85</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于函数以及初始化方法，除非上下文含义非常清楚，推荐对所有的参数都加以命名。如果外部参数名称可以使得函数调用更易读，请加上它。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">func</span> <span class="n">dateFromString</span><span class="p">(</span><span class="ss">dateString</span><span class="p">:</span> <span class="no">NSString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="no">NSDate</span>
</span><span class='line'><span class="n">func</span> <span class="n">convertPointAt</span><span class="p">(</span><span class="c1">#column: Int, #row: Int) -&gt; CGPoint</span>
</span><span class='line'><span class="n">func</span> <span class="n">timedAction</span><span class="p">(</span><span class="c1">#delay: NSTimeInterval, perform action: SKAction) -&gt; SKAction!</span>
</span><span class='line'>
</span><span class='line'><span class="sr">//</span> <span class="err">会被这样调用</span>
</span><span class='line'><span class="n">dateFromString</span><span class="p">(</span><span class="s2">&quot;2014-03-14&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">convertPointAt</span><span class="p">(</span><span class="ss">column</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span> <span class="ss">row</span><span class="p">:</span> <span class="mi">13</span><span class="p">)</span>
</span><span class='line'><span class="n">timedAction</span><span class="p">(</span><span class="ss">delay</span><span class="p">:</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span><span class="p">,</span> <span class="ss">perform</span><span class="p">:</span> <span class="n">someOtherAction</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于方法，遵循苹果公司的命名规范，在方法名中提及第一个参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Guideline</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">combineWithString</span><span class="p">(</span><span class="ss">incoming</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="ss">options</span><span class="p">:</span> <span class="no">Dictionary</span><span class="sc">?)</span> <span class="p">{</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">upvoteBy</span><span class="p">(</span><span class="ss">amount</span><span class="p">:</span> <span class="no">Int</span><span class="p">)</span> <span class="p">{</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在所有提及到函数的内容中（包括教程，书以及评论），请从调用者的视角进行考虑，将所有的必要参数名都包含进来：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">dateFromString</span><span class="p">()</span><span class="err">函数真是太棒了。</span>
</span><span class='line'><span class="err">在你的</span><span class="n">init</span><span class="p">()</span><span class="err">方法中调用</span><span class="n">convertPointAt</span><span class="p">(</span><span class="ss">column</span><span class="p">:,</span> <span class="ss">row</span><span class="p">:)</span><span class="err">。</span>
</span><span class='line'><span class="n">timedAction</span><span class="p">(</span><span class="ss">delay</span><span class="p">:,</span> <span class="ss">perform</span><span class="p">:)</span><span class="err">的返回值可能为</span><span class="kp">nil</span><span class="err">。</span>
</span><span class='line'><span class="no">Guideline</span><span class="err">对象只有两个方法：</span><span class="n">combineWithString</span><span class="p">(</span><span class="ss">options</span><span class="p">:)</span><span class="err">和</span><span class="n">upvoteBy</span><span class="p">()</span><span class="err">。</span>
</span><span class='line'><span class="err">你不应该直接调用数据源方法</span><span class="n">tableView</span><span class="p">(</span><span class="ss">cellForRowAtIndexPath</span><span class="p">:)</span><span class="err">。</span>
</span></code></pre></td></tr></table></div></figure>


<h3>类前缀</h3>

<p>Swift中的类型会被自动加入包含它们的模块的命名空间。所以减少命名冲突的前缀已经不必要了。如果同模块的两个名称冲突了，可以在名称前加上模块名消除歧义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">import</span> <span class="no">MyModule</span>
</span><span class='line'>
</span><span class='line'><span class="n">var</span> <span class="n">myClass</span> <span class="o">=</span> <span class="no">MyModule</span><span class="o">.</span><span class="n">MyClass</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不应该</strong>给自己创建的Swift类型加前缀。</p>

<p>如果需要把Swift类型暴露给Objective-C使用，你可以添加一个合适的前缀（前缀的命名请参考<a href="https://github.com/raywenderlich/objective-c-style-guide">Objective-C风格指南</a>）:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="vi">@objc</span> <span class="p">(</span><span class="no">RWTChicken</span><span class="p">)</span> <span class="k">class</span> <span class="nc">Chicken</span> <span class="p">{</span>
</span><span class='line'>   <span class="o">.</span><span class="n">.</span><span class="o">.</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>分号</h2>

<p>Swift不要求每条语句后加分号。只有在你想把多条语句写到一行时才需要加上分号。</p>

<p>请不要在一行中写上用分号隔开的多条语句。</p>

<p>这条规则的唯一例外就是<code>for-conditional-increment</code>结构，该结构中分号是必需的。不过请尽量用<code>for-in</code>结构代替它们。</p>

<p><strong>优选：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">var</span> <span class="n">swift</span> <span class="o">=</span> <span class="s2">&quot;not a scripting language&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不建议使用：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">var</span> <span class="n">swift</span> <span class="o">=</span> <span class="s2">&quot;not a scripting language&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>请注意</strong>：Swift与JavaScript不同, 在后者中省略分号<a href="http://stackoverflow.com/questions/444080/do-you-recommend-using-semicolons-after-every-statement-in-javascript">通常是不安全的</a>。</p>

<h2>类与结构体</h2>

<p>下面是一个风格良好的类定义代码例子，请参考：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Circle</span><span class="p">:</span> <span class="no">Shape</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">var</span> <span class="ss">x</span><span class="p">:</span> <span class="no">Int</span><span class="p">,</span> <span class="ss">y</span><span class="p">:</span> <span class="no">Int</span>
</span><span class='line'>  <span class="n">var</span> <span class="ss">radius</span><span class="p">:</span> <span class="no">Double</span>
</span><span class='line'>  <span class="n">var</span> <span class="ss">diameter</span><span class="p">:</span> <span class="no">Double</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">get</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">set</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">radius</span> <span class="o">=</span> <span class="n">newValue</span> <span class="o">/</span> <span class="mi">2</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">init</span><span class="p">(</span><span class="ss">x</span><span class="p">:</span> <span class="no">Int</span><span class="p">,</span> <span class="ss">y</span><span class="p">:</span> <span class="no">Int</span><span class="p">,</span> <span class="ss">radius</span><span class="p">:</span> <span class="no">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">convenience</span> <span class="n">init</span><span class="p">(</span><span class="ss">x</span><span class="p">:</span> <span class="no">Int</span><span class="p">,</span> <span class="ss">y</span><span class="p">:</span> <span class="no">Int</span><span class="p">,</span> <span class="ss">diameter</span><span class="p">:</span> <span class="no">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="ss">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="ss">y</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="ss">radius</span><span class="p">:</span> <span class="n">diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">func</span> <span class="n">describe</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">&quot;I am a circle at (\(x),\(y)) with an area of \(computeArea())&quot;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">func</span> <span class="n">computeArea</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="no">Double</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="no">M_PI</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子阐述了如下的风格准则：</p>

<ul>
<li>给属性、变量、常量、参数及其它语句指定类型时，在冒号的后面加上空格而不是前面，比如：<code>x: Int</code>跟<code>Circle: Shape</code>。</li>
<li>对getter跟setter定义以及属性观察器进行缩进。</li>
<li>如果多个变量、结构有着同样的目的或者上下文，在同一行上进行定义。</li>
</ul>


<h2>Self的使用</h2>

<p>在Swift中访问对象属性或调用方法时不需要使用<code>self</code>，请避免使用它。</p>

<p>使用<code>self</code>的唯一理由是在初始化一个类或结构体时区分属性名和参数名：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">BoardLocation</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">let</span> <span class="ss">row</span><span class="p">:</span> <span class="no">Int</span><span class="p">,</span> <span class="ss">column</span><span class="p">:</span> <span class="no">Int</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">init</span><span class="p">(</span><span class="ss">row</span><span class="p">:</span> <span class="no">Int</span><span class="p">,</span><span class="ss">column</span><span class="p">:</span> <span class="no">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">row</span> <span class="o">=</span> <span class="n">row</span>
</span><span class='line'>    <span class="nb">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">column</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>函数声明</h2>

<p>保持函数声明短小精悍，保持在一行内，花括号在同一行内开始：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">func</span> <span class="n">reticulateSplines</span><span class="p">(</span><span class="ss">spline</span><span class="p">:</span> <span class="o">[</span><span class="no">Double</span><span class="o">]</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="no">Bool</span> <span class="p">{</span>
</span><span class='line'>  <span class="sr">//</span> <span class="n">reticulate</span> <span class="n">code</span> <span class="n">goes</span> <span class="n">here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于有着长签名的函数，请在适当的位置进行断行且对后续行缩进一级：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">func</span> <span class="n">reticulateSplines</span><span class="p">(</span><span class="ss">spline</span><span class="p">:</span> <span class="o">[</span><span class="no">Double</span><span class="o">]</span><span class="p">,</span> <span class="ss">adjustmentFactor</span><span class="p">:</span> <span class="no">Double</span><span class="p">,</span>
</span><span class='line'>    <span class="ss">translateConstant</span><span class="p">:</span> <span class="no">Int</span><span class="p">,</span> <span class="ss">comment</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="no">Bool</span> <span class="p">{</span>
</span><span class='line'>  <span class="sr">//</span> <span class="n">reticulate</span> <span class="n">code</span> <span class="n">goes</span> <span class="n">here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>闭包</h2>

<p>尽可能地使用尾闭包语法。在所有的情况下给闭包参数一个描述性强的名称：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">return</span> <span class="no">SKAction</span><span class="o">.</span><span class="n">customActionWithDuration</span><span class="p">(</span><span class="n">effect</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span> <span class="p">{</span> <span class="n">node</span><span class="p">,</span> <span class="n">elapsedTime</span> <span class="k">in</span>
</span><span class='line'>  <span class="sr">//</span> <span class="n">more</span> <span class="n">code</span> <span class="n">goes</span> <span class="n">here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于上下文清晰的单表达式闭包，使用隐式的返回值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">attendeeList</span><span class="o">.</span><span class="n">sort</span> <span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="k">in</span>
</span><span class='line'>  <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>类型</h2>

<p>如果可能，使用Swift的原生类型。Swift提供了对Objective-C的桥接，如果需要，仍然可以使用全部的Objective-C方法：</p>

<p><strong>优选：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">let</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">120</span><span class="o">.</span><span class="mi">0</span>                                           <span class="o">//</span><span class="no">Double</span>
</span><span class='line'><span class="n">let</span> <span class="n">widthString</span> <span class="o">=</span> <span class="n">width</span><span class="o">.</span><span class="n">bridgeToObjectiveC</span><span class="p">()</span><span class="o">.</span><span class="n">stringValue</span>    <span class="sr">//</span><span class="nb">String</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不建议使用：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">let</span> <span class="ss">width</span><span class="p">:</span> <span class="no">NSNumber</span> <span class="o">=</span> <span class="mi">120</span><span class="o">.</span><span class="mi">0</span>                                 <span class="o">//</span><span class="no">NSNumber</span>
</span><span class='line'><span class="n">let</span> <span class="ss">widthString</span><span class="p">:</span> <span class="no">NSString</span> <span class="o">=</span> <span class="n">width</span><span class="o">.</span><span class="n">stringValue</span>               <span class="sr">//</span><span class="no">NSString</span>
</span></code></pre></td></tr></table></div></figure>


<p>在Sprite Kit的代码中，如果<code>CGFloat</code>可以避免过多的转换从而使得代码简洁，那么请使用它。</p>

<h3>常量</h3>

<p>常量通过<code>let</code>关键字定义，而变量使用<code>var</code>关键字定义。任何值如果<strong>是</strong>一个不变量，那么请使用<code>let</code>关键字恰如其分地定义它。最后你会发现自己喜欢使用<code>let</code>远多于<code>far</code>。</p>

<p><strong>Tip：</strong>有一个方法可以帮你满足该项规则，将所有值都定义成常量，然后编译器提示的时候将其改为变量。</p>

<h3>Optional</h3>

<p>在nil值可能出现的情况下，将变量跟函数返回值的类型通过<code>?</code>定义成Optional。</p>

<p>只有在确定实例变量会在初始化之后才被使用的情况下，通过<code>!</code>将其定义为隐式解包类型（Implicitly Unwrapped Types），比如说会在<code>viewDidLoad</code>中被创建的子视图。</p>

<p>在访问一个Optional值时，如果该值只被访问一次，或者之后需要连续访问多个Optional值，请使用链式Optional语法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">myOptional?</span><span class="o">.</span><span class="n">anotherOne?</span><span class="o">.</span><span class="n">optionalView?</span><span class="o">.</span><span class="n">setNeedsDisplay</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于需要将Optional值解开一次，然后进行多个操作的情况，使用Optional绑定更为方便：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">view</span> <span class="o">=</span> <span class="nb">self</span><span class="o">.</span><span class="n">optionalView</span> <span class="p">{</span>
</span><span class='line'>  <span class="sr">//</span> <span class="k">do</span> <span class="n">many</span> <span class="n">things</span> <span class="n">with</span> <span class="n">view</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>类型推导</h3>

<p>Swift的编译器可以推导出变量和常量的类型。可以显式地提供类型别名（冒号后面声明的类型），不过大多数情况下这都是不必要的。</p>

<p>保持代码紧凑，然后让编译器推断变量跟常量的类型。</p>

<p><strong>优选：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">let</span> <span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Click the button&quot;</span>
</span><span class='line'><span class="n">var</span> <span class="n">currentBounds</span> <span class="o">=</span> <span class="n">computeViewBounds</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不建议使用：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">let</span> <span class="ss">message</span><span class="p">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="s2">&quot;Click the button&quot;</span>
</span><span class='line'><span class="n">var</span> <span class="ss">currentBounds</span><span class="p">:</span> <span class="no">CGRect</span> <span class="o">=</span> <span class="n">computeViewBounds</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意</strong>：遵循这条准则意味着使用描述性强的名称比之前更为重要了。</p>

<h3>语法糖</h3>

<p>Prefer the shortcut versions of type declarations over the full generics syntax.</p>

<p>使用简写的类型声明，而不是它的全泛型版本。</p>

<p><strong>优选：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">var</span> <span class="ss">deviceModels</span><span class="p">:</span> <span class="o">[</span><span class="nb">String</span><span class="o">]</span>
</span><span class='line'><span class="n">var</span> <span class="ss">employees</span><span class="p">:</span> <span class="o">[</span><span class="ss">Int</span><span class="p">:</span> <span class="nb">String</span><span class="o">]</span>
</span><span class='line'><span class="n">var</span> <span class="ss">faxNumber</span><span class="p">:</span> <span class="no">Int</span><span class="p">?</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不建议使用：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">var</span> <span class="ss">deviceModels</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">var</span> <span class="ss">employees</span><span class="p">:</span> <span class="no">Dictionary</span><span class="o">&lt;</span><span class="no">Int</span><span class="p">,</span> <span class="nb">String</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">var</span> <span class="ss">faxNumber</span><span class="p">:</span> <span class="no">Optional</span><span class="o">&lt;</span><span class="no">Int</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>控制流</h2>

<p>对于<code>for</code>循环，优选<code>for-in</code>风格而不是<code>for-condition-increment</code>风格：</p>

<p><strong>优选：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">&lt;</span><span class="mi">3</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">println</span><span class="p">(</span><span class="s2">&quot;Hello three times&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">person</span> <span class="k">in</span> <span class="n">attendeeList</span> <span class="p">{</span>
</span><span class='line'>  <span class="sr">//</span> <span class="k">do</span> <span class="n">something</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不建议使用：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">for</span> <span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">println</span><span class="p">(</span><span class="s2">&quot;Hello three times&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">attendeeList</span><span class="o">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">person</span> <span class="o">=</span> <span class="n">attendeeList</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
</span><span class='line'>  <span class="sr">//</span> <span class="k">do</span> <span class="n">something</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>笑脸</h2>

<p>笑脸对于raywenderlich.com来说是一个格外重要的风格特征。使用正确的笑脸可以表示出对某个主题的无穷尽的高兴以及兴奋程度。选用了<code>]</code>是因为它在ASCII艺术可以表示得最大的笑脸。而闭圆括号<code>)</code>因为给人一种“<strong>呵呵</strong>”的感觉而不建议使用。</p>

<p><strong>优选：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">:</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>不建议使用：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">:)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>致谢</h2>

<p>该风格指南是由下面这些格外有范儿的raywenderlich.com团队成员齐心协力一同打造：</p>

<ul>
<li><a href="https://github.com/moayes">Soheil Moayedi Azarpour</a></li>
<li><a href="https://github.com/Scott90">Scott Berrevoets</a></li>
<li><a href="https://github.com/ecerney">Eric Cerney</a></li>
<li><a href="https://github.com/sammyd">Sam Davies</a></li>
<li><a href="https://github.com/edekhayser">Evan Dekhayser</a></li>
<li><a href="https://github.com/pdistler">Jean-Pierre Distler</a></li>
<li><a href="https://github.com/ColinEberhardt">Colin Eberhardt</a></li>
<li><a href="https://github.com/gregheo">Greg Heo</a></li>
<li><a href="https://github.com/hollance">Matthijs Hollemans</a></li>
<li><a href="https://github.com/eskerber">Erik Kerber</a></li>
<li><a href="https://github.com/elephantronic">Christopher LaPollo</a></li>
<li><a href="https://github.com/macandyp">Andy Pereira</a></li>
<li><a href="https://github.com/rnystrom">Ryan Nystrom</a></li>
<li><a href="https://github.com/funkyboy">Cesare Rocchi</a></li>
<li><a href="https://github.com/designatednerd">Ellen Shapiro</a></li>
<li><a href="https://github.com/icanzilb">Marin Todorov</a></li>
<li><a href="https://github.com/cwagdev">Chris Wagner</a></li>
<li><a href="https://github.com/rwenderlich">Ray Wenderlich</a></li>
<li><a href="https://github.com/jackwu95">Jack Wu</a></li>
</ul>


<p>向<a href="https://github.com/ndubbs">Nicholas Waynik</a>以及<a href="https://github.com/raywenderlich/objective-c-style-guide">Objective-C风格指南</a>团队脱帽致礼！</p>

<p>我们也从苹果公司的有关Swift的参考材料中获取了灵感：</p>

<ul>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/index.html">The Swift Programming Language</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html">Using Swift with Cocoa and Objective-C</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Reference/SwiftStandardLibraryReference/index.html">Swift Standard Library Reference</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从Objective-C转移到Swift需要注意的地方]]></title>
    <link href="http://BOOLRon.github.io/blog/2014/09/02/cong-objective-czhuan-yi-dao-xu-yao-zhu-yi-de-di-fang/"/>
    <updated>2014-09-02T20:41:46+08:00</updated>
    <id>http://BOOLRon.github.io/blog/2014/09/02/cong-objective-czhuan-yi-dao-xu-yao-zhu-yi-de-di-fang</id>
    <content type="html"><![CDATA[<p>我想通过这文章分享一下我从Objective-C转移到Swift过程中的一些想法。我会给你一些提示并讨论相关的陷阱，尽可能去比较两种语言的方法有何不同。废话不多说，马上开始！</p>

<h3>xxx.swift VS xxx.h&amp;xxx.m</h3>

<p>第一个要注意的大变化是，Swift不采用interface.h/implementation.m的结构。其实我是非常支持把需要共享的信息放头文件的，这样很安全。而Swift，不再分开头文件与实现文件了，只需要实现我们的class。</p>

<p>自从Xcode6 beta4开始，Swift加入了三个访问权限控制修饰词：</p>

<ul>
<li>private 只能被相同源文件下被访问</li>
<li>internal 只能被当前target下的文件访问</li>
<li>public 可以被属于当前target的module下的所有文件访问</li>
</ul>


<p>三个中internal是默认的，另外对属性加修饰词可以设置只对set方法成效，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">//</span> <span class="err">这样对于其他文件是只读不可写了</span>
</span><span class='line'><span class="kp">private</span><span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="n">var</span> <span class="ss">UUID</span><span class="p">:</span> <span class="no">NSUUID</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>而当你需要重载声明了public修饰词的方法时，你也必须要加public的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="kp">public</span> <span class="n">override</span> <span class="n">func</span> <span class="n">isEqual</span><span class="p">(</span><span class="ss">object</span><span class="p">:</span> <span class="no">AnyObject</span><span class="sc">?)</span> <span class="o">-&gt;</span> <span class="no">Bool</span><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">let</span> <span class="n">item</span> <span class="o">=</span> <span class="n">object</span> <span class="n">as?</span> <span class="no">ListItem</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nb">self</span><span class="o">.</span><span class="n">UUID</span> <span class="o">==</span> <span class="n">item</span><span class="o">.</span><span class="n">UUID</span>
</span><span class='line'>  <span class="p">}</span>    
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>常量与变量</h3>

<p>在写Objective-C时，我知道有些数据不应该被改变也是比较少用<strong>const</strong>的（请不要耻笑我）。而在Swift，苹果建议开发者更多去思考，能用常量(<strong>let</strong>)，就少用变量(<strong>var</strong>)。这样你只需要专注于如何使你定义的变量发挥作用。</p>

<h3>只写需要的代码</h3>

<p>举个栗子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">let</span> <span class="ss">wsURL</span><span class="p">:</span><span class="no">NSURL</span> <span class="o">=</span> <span class="no">NSURL</span><span class="p">(</span><span class="ss">string</span><span class="p">:</span><span class="s2">&quot;http://wsurl.com&quot;</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;!----&gt;</span>
</span><span class='line'><span class="n">let</span> <span class="n">wsURL</span> <span class="o">=</span> <span class="no">NSURL</span><span class="p">(</span><span class="ss">string</span><span class="p">:</span><span class="s2">&quot;http://wsurl.com&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>经过两周训练写Swift，我强迫自己去掉每行代码的分号。最后我感觉整个人都舒服了，然后我经常写Objective-C漏掉了分号，呵呵。</p>

<p><strong>Type inference</strong>是指通过赋值时的声明来推断出实例的类型，这种方便的写法使得习惯了冗长派语言（如Objective-C）的我有点措手不及。</p>

<p>另一种情况是在if里买不一定需要括号：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="o">&lt;!----&gt;</span>
</span><span class='line'><span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>以上是一样的，另外如果你要在if里面赋值是不能加括号的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="p">){}</span> <span class="sr">//</span><span class="no">Error</span><span class="o">!</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">data</span><span class="p">{}</span>  <span class="sr">//</span><span class="no">OK</span><span class="o">!</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Optionals</h3>

<p>很多时候函数返回的会是<strong>值</strong>或者<strong>空</strong>，而你会用什么方案来返回这个<strong>空</strong>呢？我会使用<strong>NSNotFound</strong>,<strong>-1</strong>,<strong>0</strong>或<strong>nil</strong>。得益于Optionals，现在<strong>空</strong>有了官方的完整定义，我们只需在数据类型后加问号就行了。</p>

<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Car</span><span class="p">{</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">accelerate</span><span class="p">(){</span>
</span><span class='line'>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;accelerate&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>  
</span><span class='line'><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nb">name</span><span class="ss">:String</span>
</span><span class='line'>    <span class="n">let</span> <span class="ss">car</span><span class="p">:</span><span class="no">Car</span><span class="p">?</span> <span class="sr">//</span> <span class="no">Optional</span> <span class="n">value</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nb">name</span><span class="ss">:String</span><span class="p">){</span>
</span><span class='line'>        <span class="nb">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">name</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="sr">//</span> <span class="no">ACCESSING</span> <span class="no">THE</span> <span class="no">OPTIONAL</span> <span class="no">VALUE</span> <span class="o">***********</span>
</span><span class='line'><span class="n">var</span> <span class="no">Mark</span> <span class="o">=</span> <span class="no">Person</span><span class="p">(</span><span class="nb">name</span><span class="ss">:&quot;mark&quot;</span><span class="p">)</span>
</span><span class='line'><span class="sr">//</span> <span class="n">use</span> <span class="n">optional</span> <span class="nb">binding</span>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">car</span> <span class="o">=</span> <span class="no">Mark</span><span class="o">.</span><span class="n">car</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">car</span><span class="o">.</span><span class="n">accelerate</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="sr">//</span> <span class="n">unwrap</span> <span class="n">the</span> <span class="n">value</span>
</span><span class='line'><span class="no">Mark</span><span class="o">.</span><span class="n">car?</span><span class="o">.</span><span class="n">accelerate</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个例子中，Person有Car被定义成一个Optional。这意味着属性car可以为空，然后我们可以通过Optional binding(if let car =)或者unwrap(car?)来访问到里面的值。
如果我们定义某属性不为Optional，那么我们必须要设一个值给它，否则编译器就会不高兴了。我们需要决定好class的属性怎样与其它class相互调用，Optional完全改变了我们构思class的方式。</p>

<h3>Optionals Unwrapping</h3>

<p>当你发现Optional很难用时，那是因为你对它还不够了解&hellip;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Mark</span><span class="o">.</span><span class="n">car?</span>
</span></code></pre></td></tr></table></div></figure>


<p>建议你把Optional想象成一个封起来的盒子，当你不肯定里面有没有值时，可以在Optional后面加<strong>?</strong>就代表解封，你即可看到里面的值或者是一个空盒子。而你敢肯定里面绝对有值时，可以在后面加<strong>!</strong>就可以直接获取到值了，但这有个风险，程序运行发现跟你断言的不一样就会马上闪退。</p>

<h3>Delegate模式</h3>

<p>写了多年的Objective-C，我们都已习惯了这种模式，下面用Swift实现一个简单的delegate:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="vi">@objc</span> <span class="n">protocol</span> <span class="no">DataReaderDelegate</span><span class="p">{</span>
</span><span class='line'>    <span class="vi">@optional</span> <span class="n">func</span> <span class="no">DataWillRead</span><span class="p">()</span>
</span><span class='line'>    <span class="n">func</span> <span class="no">DataDidRead</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="nc">DataReader</span><span class="p">:</span> <span class="no">NSObject</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="ss">delegate</span><span class="p">:</span><span class="no">DataReaderDelegate</span><span class="p">?</span>
</span><span class='line'>    <span class="n">var</span> <span class="ss">data</span><span class="p">:</span><span class="no">NSData</span><span class="p">?</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">buildData</span><span class="p">(){</span>
</span><span class='line'>        <span class="n">delegate?</span><span class="o">.</span><span class="n">DataWillRead?</span><span class="p">()</span> <span class="sr">//</span> <span class="no">Optional</span> <span class="nb">method</span> <span class="n">check</span>
</span><span class='line'>        <span class="n">data</span> <span class="o">=</span> <span class="n">_createData</span><span class="p">()</span>
</span><span class='line'>        <span class="n">delegate?</span><span class="o">.</span><span class="n">DataDidRead</span><span class="p">()</span>       <span class="sr">//</span> <span class="no">Required</span> <span class="nb">method</span> <span class="n">check</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
以往我们需要用<strong>respondToSelector</strong>来判断对象是否响应这个方法(真心觉得太烦了)，现在有了Optional就可以简化成：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">delegate?</span><span class="o">.</span><span class="n">DataWillRead?</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后就是在另外的class上实现delegate了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">ViewController</span><span class="p">:</span> <span class="no">UIViewController</span><span class="p">,</span> <span class="no">DataReaderDelegate</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">override</span> <span class="n">func</span> <span class="n">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">super</span><span class="o">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
</span><span class='line'>        <span class="n">let</span> <span class="n">reader</span> <span class="o">=</span> <span class="no">DataReader</span><span class="p">()</span>
</span><span class='line'>        <span class="n">reader</span><span class="o">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">func</span> <span class="no">DataWillRead</span><span class="p">()</span> <span class="p">{</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">}</span>
</span><span class='line'>    <span class="n">func</span> <span class="no">DataDidRead</span><span class="p">()</span> <span class="p">{</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Target-Action模式</h3>

<p>另一种常用模式是target-action模式，你会发现写法跟Objective-C差别不大：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">ViewController</span><span class="p">:</span> <span class="no">UIViewController</span> <span class="p">{</span>
</span><span class='line'>    <span class="vi">@IBOutlet</span> <span class="n">var</span> <span class="ss">button</span><span class="p">:</span><span class="no">UIButton</span>
</span><span class='line'>    <span class="n">override</span> <span class="n">func</span> <span class="n">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">super</span><span class="o">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
</span><span class='line'>      <span class="n">button</span><span class="o">.</span><span class="n">addTarget</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="ss">action</span><span class="p">:</span> <span class="s2">&quot;buttonPressed:&quot;</span><span class="p">,</span> <span class="ss">forControlEvents</span><span class="p">:</span> <span class="no">UIControlEvents</span><span class="o">.</span><span class="n">TouchUpInside</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">buttonPressed</span><span class="p">(</span><span class="ss">sender</span><span class="p">:</span><span class="no">UIButton</span><span class="p">){</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最大不同在于selector的定义。我们可以直接写用String写成:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Selector</span><span class="p">(</span><span class="s2">&quot;buttonPressed:&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>单例模式</h3>

<p>无论你喜不喜欢，单例模式仍然是最常用开发设计模式之一。除了结合GDC和dispatch_once来实现之外，我们还可以使用线程安全的<strong>let</strong>实现。</p>

<pre><code>class DataReader: NSObject {
    class var sharedReader:DataReader {
        struct Static{
            static let _instance = DataReader()
        }
        return Static._instance
    }
...
}
</code></pre>

<p>分析一下</p>

<p>1.我们ShareReader可看成包装起来的静态属性；
2.而真正的静态属性我用struct来封起来不允许别的class修改；
3._instance是一个常量，它不能被修改成别的值。</p>

<p>使用：</p>

<pre><code>DataReader.sharedReader
</code></pre>

<p>自从Xcode6 beta4加入了访问修饰词，我们现在可以简单的写成：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="kp">private</span> <span class="n">let</span> <span class="n">_instance</span> <span class="o">=</span> <span class="no">DataReader</span><span class="p">()</span>
</span><span class='line'><span class="k">class</span> <span class="nc">DataReader</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">class</span> <span class="n">var</span> <span class="ss">sharedReader</span><span class="p">:</span><span class="no">DataReader</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">_instance</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>结构体与枚举</h3>

<p>Swift的结构体与枚举有很多强大特性你是在别的语言找不到的。</p>

<p>它们支持写方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">struct</span> <span class="no">User</span><span class="p">{</span>
</span><span class='line'>    <span class="sr">//</span> <span class="no">Struct</span> <span class="n">properties</span>
</span><span class='line'>    <span class="n">let</span> <span class="nb">name</span><span class="ss">:String</span>
</span><span class='line'>    <span class="n">let</span> <span class="ss">ID</span><span class="p">:</span><span class="no">Int</span>
</span><span class='line'>    <span class="sr">//</span> <span class="no">Method</span><span class="o">!!!</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">sayHello</span><span class="p">(){</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s2">&quot;I&#39;m &quot;</span> <span class="o">+</span> <span class="nb">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; my ID is: \(self.ID)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="n">pamela</span> <span class="o">=</span> <span class="no">User</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;Pamela&quot;</span><span class="p">,</span> <span class="ss">ID</span><span class="p">:</span> <span class="mi">123456</span><span class="p">)</span>
</span><span class='line'><span class="n">pamela</span><span class="o">.</span><span class="n">sayHello</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>
可以见到Swift对结构体有默认的initializer。而枚举的语法有很大不同是用了<strong>case</strong>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">enum</span> <span class="no">Fruit</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">orange</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">apple</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>不再限制与整数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">enum</span> <span class="ss">Fruit</span><span class="p">:</span><span class="nb">String</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">.</span><span class="n">orange</span> <span class="o">=</span> <span class="s2">&quot;Orange&quot;</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">.</span><span class="n">apple</span> <span class="o">=</span> <span class="s2">&quot;Apple&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
甚至可以给它定义更多行为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">enum</span> <span class="no">Fruit</span><span class="p">{</span>
</span><span class='line'>    <span class="sr">//</span> <span class="no">Available</span> <span class="no">Fruits</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">orange</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">apple</span>
</span><span class='line'>    <span class="sr">//</span> <span class="no">Nested</span> <span class="n">type</span>
</span><span class='line'>    <span class="n">struct</span> <span class="no">Vitamin</span><span class="p">{</span>
</span><span class='line'>        <span class="n">var</span> <span class="nb">name</span><span class="ss">:String</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="sr">//</span> <span class="no">Compound</span> <span class="n">property</span>
</span><span class='line'>    <span class="n">var</span> <span class="ss">mainVitamin</span><span class="p">:</span><span class="no">Vitamin</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">switch</span> <span class="nb">self</span><span class="p">{</span>
</span><span class='line'>          <span class="k">case</span> <span class="o">.</span><span class="n">orange</span><span class="p">:</span>
</span><span class='line'>          <span class="k">return</span> <span class="no">Vitamin</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">.</span><span class="n">apple</span><span class="p">:</span>
</span><span class='line'>          <span class="k">return</span> <span class="no">Vitamin</span><span class="p">(</span><span class="nb">name</span><span class="p">:</span> <span class="s2">&quot;B&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">let</span> <span class="no">Apple</span> <span class="o">=</span> <span class="no">Fruit</span><span class="o">.</span><span class="n">apple</span>
</span><span class='line'><span class="n">var</span> <span class="no">Vitamin</span> <span class="o">=</span> <span class="no">Apple</span><span class="o">.</span><span class="n">mainVitamin</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码我们加了一个内嵌类型(Vitamin)和一个compound property(mainVitamin)，这样不同的枚举值出来的mainVitamin就不一样了，这功能真赞！</p>

<h3>Blocks VS Closures</h3>

<p>我非常喜欢blocks，一些简单的delegate我都爱用blocks来替代，它灵活、快速、安全。而在Swift里是用Closures来代替Blocks的。它再续了Blocks的优点，简化了语法，令我爱不惜手。
以下是官方用Closures实现reversed的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">reversed</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">{</span> <span class="p">(</span><span class="ss">s1</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="ss">s2</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="no">Bool</span> <span class="k">in</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>
简化成：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">reversed</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="o">&gt;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
这里我就不详解Closure的语法了，我来说说Closure的<strong>capture values</strong>。在Objective-C我们需要给变量加<strong>__block</strong>才能在block里面修改该外部变量。而用Closure，这不需要，我们能在Closures里访问和修改外部作用域的变量。另外，如果Closure里引用的实例包含或使用了Closure本身，这就会引起<strong>循环引用</strong>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span><span class='line'>    <span class="n">var</span> <span class="ss">age</span><span class="p">:</span><span class="no">Int</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="vi">@lazy</span> <span class="n">var</span> <span class="ss">agePotion</span><span class="p">:</span> <span class="p">(</span><span class="no">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="no">Void</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">(</span><span class="ss">agex</span><span class="p">:</span><span class="no">Int</span><span class="p">)</span><span class="o">-&gt;</span><span class="no">Void</span> <span class="k">in</span>
</span><span class='line'>            <span class="nb">self</span><span class="o">.</span><span class="n">age</span> <span class="o">+=</span> <span class="n">agex</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">func</span> <span class="n">modifyAge</span><span class="p">(</span><span class="ss">agex</span><span class="p">:</span><span class="no">Int</span><span class="p">,</span> <span class="ss">modifier</span><span class="p">:(</span><span class="no">Int</span><span class="p">)</span><span class="o">-&gt;</span><span class="no">Void</span><span class="p">){</span>
</span><span class='line'>        <span class="n">modifier</span><span class="p">(</span><span class="n">agex</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="ss">Mark</span><span class="p">:</span><span class="no">Person</span><span class="p">?</span> <span class="o">=</span> <span class="no">Person</span><span class="p">()</span>
</span><span class='line'><span class="no">Mark</span><span class="o">!.</span><span class="n">modifyAge</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="no">Mark</span><span class="o">!.</span><span class="n">agePotion</span><span class="p">)</span>
</span><span class='line'><span class="no">Mark</span> <span class="o">=</span> <span class="kp">nil</span> <span class="sr">//</span> <span class="no">Memory</span> <span class="no">Leak</span>
</span></code></pre></td></tr></table></div></figure>


<p>
看到agePotion里用了self，<strong>循环引用</strong>就发生了，要避免这问题，我们可以用<strong>Capture List</strong>，这会时分配进Closure的实例是weak或者unowned的，写法也很简单，只需在Closure的定义前加上<strong>[unownded self]</strong>，就可以得到一个unowned或者weak的self了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="vi">@lazy</span> <span class="n">var</span> <span class="ss">agePotion</span><span class="p">:</span> <span class="p">(</span><span class="no">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="no">Void</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>     <span class="o">[</span><span class="n">unowned</span> <span class="nb">self</span><span class="o">]</span><span class="p">(</span><span class="ss">agex</span><span class="p">:</span><span class="no">Int</span><span class="p">)</span><span class="o">-&gt;</span><span class="no">Void</span> <span class="k">in</span>
</span><span class='line'>         <span class="nb">self</span><span class="o">.</span><span class="n">age</span> <span class="o">+=</span> <span class="n">agex</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>Unowned &amp; Weak Reference</h3>

<p>我们知道<strong>weak Reference</strong>在Objective-C的使用，在Swift上也是一样的。那么<strong>unowned reference</strong>又是什么呢？我就举个例子来解析吧。</p>

<p>我来描述一下一个人与他的银行账号的关系：</p>

<p>1.一个人可以有一个银行账号(optional)</p>

<p>2.一个银行账号必须有拥有者(required)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">//</span><span class="no">We</span> <span class="n">can</span> <span class="n">describe</span> <span class="n">this</span> <span class="n">relation</span> <span class="n">with</span> <span class="ss">code</span><span class="p">:</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="nb">name</span><span class="ss">:String</span>
</span><span class='line'>    <span class="n">let</span> <span class="ss">account</span><span class="p">:</span><span class="no">BankAccount</span><span class="o">!</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="nb">name</span><span class="ss">:String</span><span class="p">){</span>
</span><span class='line'>        <span class="nb">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">name</span>
</span><span class='line'>        <span class="nb">self</span><span class="o">.</span><span class="n">account</span> <span class="o">=</span> <span class="no">BankAccount</span><span class="p">(</span><span class="ss">owner</span><span class="p">:</span> <span class="nb">self</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="nc">BankAccount</span><span class="p">{</span>
</span><span class='line'>    <span class="n">let</span> <span class="ss">owner</span><span class="p">:</span><span class="no">Person</span>
</span><span class='line'>    <span class="n">init</span><span class="p">(</span><span class="ss">owner</span><span class="p">:</span><span class="no">Person</span><span class="p">){</span>
</span><span class='line'>        <span class="nb">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">owner</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就生成了一个引用循环。一种解决方案是对BankAccount.owner属性添加weak reference。你也可以使用unowned reference，但这个属性就必须要非空了。总结就是<strong>unowned</strong>就只是比<strong>weak</strong>多了一个非空限制而已，其他一样的。</p>

<h3>最后</h3>

<p>在写Swift的过程中，越来越发现一些有趣的特性，这令我更想多写Swift，期待正式版Xcode 6。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift的值类型和引用类型的差别]]></title>
    <link href="http://BOOLRon.github.io/blog/2014/08/31/swiftde-zhi-lei-xing-he-yin-yong-lei-xing-de-chai-bie/"/>
    <updated>2014-08-31T19:49:25+08:00</updated>
    <id>http://BOOLRon.github.io/blog/2014/08/31/swiftde-zhi-lei-xing-he-yin-yong-lei-xing-de-chai-bie</id>
    <content type="html"><![CDATA[<p>Swift的值分两种类型：值类型和引用类型。前者的实例保存着数据相同且各自独立的副本，像struct、enum和tuple这些；而后者的实例保存同一份数据，如class。这文章我们来挖掘这两种类型各自的优点以及思考开发中要如何选用</p>

<h3>有何不同</h3>

<p>值类型的最大特点是复制，无论是初始化还是传值，它都会复制出另一个相同数据的对象出来：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">//</span> <span class="no">Value</span> <span class="n">type</span> <span class="n">example</span>
</span><span class='line'><span class="n">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="n">var</span> <span class="ss">data</span><span class="p">:</span> <span class="no">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">var</span> <span class="n">a</span> <span class="o">=</span> <span class="n">S</span><span class="p">()</span>
</span><span class='line'>  <span class="n">var</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span>                       <span class="sr">//</span> <span class="n">a</span> <span class="n">is</span> <span class="n">copied</span> <span class="n">to</span> <span class="n">b</span>
</span><span class='line'>  <span class="n">a</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">42</span>                     <span class="o">//</span> <span class="no">Changes</span> <span class="n">a</span><span class="p">,</span> <span class="ow">not</span> <span class="n">b</span>
</span><span class='line'>  <span class="n">println</span><span class="p">(</span><span class="s2">&quot;\(a.data), \(b.data)&quot;</span><span class="p">)</span>  <span class="sr">//</span> <span class="n">prints</span> <span class="s2">&quot;42, -1&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>而引用类型的赋值，则会新建另一个对象，并指向相同的共享数据地址:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="sr">//</span> <span class="no">Reference</span> <span class="n">type</span> <span class="n">example</span>
</span><span class='line'><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="n">var</span> <span class="ss">data</span><span class="p">:</span> <span class="no">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">}</span>
</span><span class='line'><span class="n">var</span> <span class="n">x</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
</span><span class='line'><span class="n">var</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span>                     <span class="sr">//</span> <span class="n">x</span> <span class="n">is</span> <span class="n">copied</span> <span class="n">to</span> <span class="n">y</span>
</span><span class='line'><span class="n">x</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">42</span>                       <span class="o">//</span> <span class="n">changes</span> <span class="n">the</span> <span class="n">instance</span> <span class="n">referred</span> <span class="n">to</span> <span class="n">by</span> <span class="n">x</span> <span class="p">(</span><span class="ow">and</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s2">&quot;\(x.data), \(y.data)&quot;</span><span class="p">)</span>    <span class="sr">//</span> <span class="n">prints</span> <span class="s2">&quot;42, 42&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>保证数据突变的安全性</h3>

<p>这是选择值类型的其中一个原因。当你获取到唯一的实例对象时，妈妈再也不用再担心你的数据在背后被偷偷修改了。尤其是在多线程环境，有可能某线程背着你改了数据而出现些难以debug的问题。</p>

<p>按道理这个不同点会发生在你改变数据那一刻，所以有一种情况下值类型和引用类型是一样的————对象无法写入时。</p>

<p>你可能会想当class为完全不可变时也会有这优点，这样我们可以简单地使用熟悉的Cocoa NSObject对象同时享有值类型的优点。现在，你可以用Swift通过immutable properties来写出immutable class，事实上，很多常用Cocoa class如NSURL都已被设计成immutable class。但是要注意，这种immutable class不是值类型。</p>

<h3>如何选用</h3>

<p>当你想新建一种类型，你如果选择用值类型还是引用类型呢？如果想你的类型和Cocoa有更有的相容性建议用class，其他情况可以参考如下几条指引：</p>

<p>使用值类型：</p>

<ul>
<li>使用 == 来比较数据是否一致</li>
<li>你希望对象有独立状态</li>
<li>数据将会被多线程使用</li>
</ul>


<p>使用引用类型：</p>

<ul>
<li>使用 === 来比较对象一致</li>
<li>你希望对象的数据是共享的、可变的</li>
</ul>


<p>在Swift的世界，Array、String和Dictionary都是值类型，他们就像C语言的int类型，保持着相对独立的数据，你不需要显式声明copy来避免数据被偷偷修改，更重要的是你可以安全地线程间传值而不需要synchronization。得益与这一特性，这可以助你用Swift写出更安全可控的代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[装机记录]]></title>
    <link href="http://BOOLRon.github.io/blog/2014/08/09/zhuang-ji-ji-lu/"/>
    <updated>2014-08-09T09:36:11+08:00</updated>
    <id>http://BOOLRon.github.io/blog/2014/08/09/zhuang-ji-ji-lu</id>
    <content type="html"><![CDATA[<hr />

<h4>GUI安装</h4>

<p>首先进入AppStore升级系统，然后通过AppStore的”Purchases”页面，重新安装以前购买过的应用，再通过网页下载输入法、Resizer、PS等</p>

<hr />

<h4>命令行安装</h4>

<p><strong>安装homebrew</strong></p>

<pre><code>ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"
</code></pre>

<p>安装完成后别忘了执行:</p>

<pre><code>brew doctor
</code></pre>

<p>然后可以用brew安装git、wget等</p>

<pre><code>brew install git
brew install wget
</code></pre>

<p><strong>brew cask</strong></p>

<p>还可以使用brew cask来安装应用，首先安装cask:</p>

<pre><code>brew tap phinze/cask
brew install brew-cask
</code></pre>

<p>接下来可以安装你需要的软件，例如：</p>

<pre><code>brew cask install google-chrome
brew cask install sublime-text
brew cask install mou
brew cask install sourcetree    
</code></pre>

<hr />

<p><strong>安装oh-my-zsh</strong></p>

<pre><code>curl -L http://install.ohmyz.sh | sh
</code></pre>

<p>安装完成之后，执行：</p>

<pre><code>subl ~/.zshrc
</code></pre>

<p>然后把以下这行注释启用：export LANG=en_US.UTF-8 ，否则命令行中的中文可能会乱码。
你也可以给一些常用命令加上别名，例如：</p>

<pre><code>alias gs='git status'
alias guod='git pull origin develop'
alias gpod='git push origin develop'
</code></pre>

<hr />

<p><strong>安装CocoaPods</strong></p>

<pre><code>sudo gem install cocoapods
</code></pre>

<p>然后执行</p>

<pre><code> pod setup
</code></pre>

<p>这是建立pod索引的过程，可能等待比较长时间，建议翻墙</p>

<hr />

<p><strong>安装Alcatraz(Xcode插件管理包)</strong></p>

<pre><code>curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh
</code></pre>

<hr />

<p><strong>安装Rvm</strong></p>

<pre><code>curl -L https://get.rvm.io | bash -s stable --ruby
</code></pre>

<p>由于我的博客使用Octopress搭建，所以安装bundler:</p>

<pre><code>gem install bundler
bundle install
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[挺喜欢Xcode的新icon]]></title>
    <link href="http://BOOLRon.github.io/blog/2014/07/30/ting-xi-huan-xcodede-xin-icon/"/>
    <updated>2014-07-30T08:58:15+08:00</updated>
    <id>http://BOOLRon.github.io/blog/2014/07/30/ting-xi-huan-xcodede-xin-icon</id>
    <content type="html"><![CDATA[<p><img src="http://testzone.qiniudn.com/Screen%20Shot%202014-07-30%20at%209.00.45%20am.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在iOS7设置合适的UINavigationBar颜色]]></title>
    <link href="http://BOOLRon.github.io/blog/2014/07/19/ru-he-zai-ios7she-zhi-he-gua-de-uinavigationbaryan-se/"/>
    <updated>2014-07-19T13:39:51+08:00</updated>
    <id>http://BOOLRon.github.io/blog/2014/07/19/ru-he-zai-ios7she-zhi-he-gua-de-uinavigationbaryan-se</id>
    <content type="html"><![CDATA[<p>Bar color calculator for iOS7 (UIToolbar and UINavigationBar)(<a href="http://b2cloud.com.au/how-to-guides/bar-color-calculator-for-ios7/">http://b2cloud.com.au/how-to-guides/bar-color-calculator-for-ios7/</a>)</p>

<p>如何在 iOS 7 中设置 barTintColor 实现类似网易和 Facebook 的 navigationBar 效果(<a href="http://imallen.com/blog/2013/10/22/how-to-set-bartintcolor-correctly-in-ios-7.html">http://imallen.com/blog/2013/10/22/how-to-set-bartintcolor-correctly-in-ios-7.html</a>)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[这博客的目的]]></title>
    <link href="http://BOOLRon.github.io/blog/2014/07/17/zhe-bo-ke-de-mu-de/"/>
    <updated>2014-07-17T09:26:06+08:00</updated>
    <id>http://BOOLRon.github.io/blog/2014/07/17/zhe-bo-ke-de-mu-de</id>
    <content type="html"><![CDATA[<p>希望通过博客记录自己的技术成长，顺便提高文笔水平</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[汇集那些未来可能会变化的Swift功能]]></title>
    <link href="http://BOOLRon.github.io/blog/2014/07/16/hui-ji-na-xie-wei-lai-ke-neng-hui-bian-hua-de-swiftgong-neng/"/>
    <updated>2014-07-16T14:42:25+08:00</updated>
    <id>http://BOOLRon.github.io/blog/2014/07/16/hui-ji-na-xie-wei-lai-ke-neng-hui-bian-hua-de-swiftgong-neng</id>
    <content type="html"><![CDATA[<p>Swift InFlux(<a href="https://github.com/ksm/SwiftInFlux">https://github.com/ksm/SwiftInFlux</a>)</p>
]]></content>
  </entry>
  
</feed>
