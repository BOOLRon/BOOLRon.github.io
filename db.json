{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/bird_32_gray.png","path":"images/bird_32_gray.png","modified":1,"renderable":0},{"_id":"source/images/bird_32_gray_fail.png","path":"images/bird_32_gray_fail.png","modified":1,"renderable":0},{"_id":"source/images/line-tile.png","path":"images/line-tile.png","modified":1,"renderable":0},{"_id":"source/images/noise.png","path":"images/noise.png","modified":1,"renderable":0},{"_id":"source/images/rss.png","path":"images/rss.png","modified":1,"renderable":0},{"_id":"source/images/email.png","path":"images/email.png","modified":1,"renderable":0},{"_id":"source/images/search.png","path":"images/search.png","modified":1,"renderable":0},{"_id":"source/images/dotted-border.png","path":"images/dotted-border.png","modified":1,"renderable":0},{"_id":"source/images/code_bg.png","path":"images/code_bg.png","modified":1,"renderable":0},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/jacman/.gitignore","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1459925217000},{"_id":"source/.DS_Store","hash":"ff9748c62d34a2360ddf43e9653c52b33f9e2d41","modified":1459923358000},{"_id":"themes/jacman/README.md","hash":"563fd972b298b6b00540b34c4cfe9485084ea8d5","modified":1459925217000},{"_id":"themes/jacman/LICENSE","hash":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1459925217000},{"_id":"themes/jacman/README_zh.md","hash":"0854e4c96f53005f3a47e21af3f8aee361719ce4","modified":1459925217000},{"_id":"themes/jacman/_config.yml","hash":"91aa55993aea0e4c7fd6e23e13ac5cb0b2836d55","modified":1459925217000},{"_id":"source/_posts/.DS_Store","hash":"74afac4794d56dbb96af8d97f982c77ad17ae5ac","modified":1459923354000},{"_id":"source/_posts/2014-07-16-hui-ji-na-xie-wei-lai-ke-neng-hui-bian-hua-de-swiftgong-neng.markdown","hash":"540555168f8e1f2089d7c170e006467fc6430bbb","modified":1405493672000},{"_id":"source/_posts/2014-08-09-zhuang-ji-ji-lu.markdown","hash":"d005d0b9902f2d543181778f32beecacef30f075","modified":1413729454000},{"_id":"source/_posts/2014-08-31-swiftde-zhi-lei-xing-he-yin-yong-lei-xing-de-chai-bie.markdown","hash":"37f05cf7fdd21b43f7a78a3810fa57ed4cc53189","modified":1410162566000},{"_id":"source/_posts/2014-09-02-cong-objective-czhuan-yi-dao-xu-yao-zhu-yi-de-di-fang.markdown","hash":"3bc6122f338fda5d8b5181f6993b784d30034079","modified":1410163036000},{"_id":"source/_posts/2014-09-08-raywenderlich-dot-com-swiftfeng-ge-zhi-nan.markdown","hash":"e41d1778e044f117f7a7d297534511d938ce9f7a","modified":1410162232000},{"_id":"source/images/.DS_Store","hash":"eed9872b3d0fa469e85fc7af7ddc4915373f6d8c","modified":1459924225000},{"_id":"source/images/bird_32_gray.png","hash":"55345ff7370047a6b825dd235c9ce201545a0952","modified":1405218417000},{"_id":"source/_posts/2016-03-06-[?]-ge-geng-ju-bao-rong-xing-de-jing-ji-fa-zhan-lan-tu.markdown","hash":"e5d3b4d49699a2097b54e820be6237522ae496b9","modified":1457261283000},{"_id":"source/images/bird_32_gray_fail.png","hash":"0c30b159e4cbb7e8a1ad826be537fc4bd79b0a8f","modified":1405218417000},{"_id":"source/images/line-tile.png","hash":"a86a5d70fb0024dd295b85ea9058b43c1c5f25d3","modified":1405218417000},{"_id":"themes/jacman/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1459925217000},{"_id":"source/images/noise.png","hash":"a839ae391fbbb0a1a2b22f8aba1d8ae2a702ef34","modified":1405218417000},{"_id":"themes/jacman/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1459925214000},{"_id":"source/images/rss.png","hash":"d61fc1ccc66f081002b15532f66e054147d5f2fb","modified":1405218417000},{"_id":"source/images/email.png","hash":"2a5d251567fabcad68fa596ebaf1508296524930","modified":1405218417000},{"_id":"themes/jacman/.git/config","hash":"78f65645e1e66052ea7fd8e0bc3f3822a93b4b97","modified":1459925217000},{"_id":"source/images/search.png","hash":"3c0178651f38bff462d4feb927e4f4df87b0f9d0","modified":1405218417000},{"_id":"source/images/dotted-border.png","hash":"347784b401d0d38acf5e3b6d06a90346a16a8e8c","modified":1405218417000},{"_id":"themes/jacman/.git/index","hash":"080e58b9899b198e51a7e460ec78ca3a2efbafd9","modified":1459925217000},{"_id":"themes/jacman/.git/packed-refs","hash":"570e9fc43f11a712a96991f6c619c2ad938c5899","modified":1459925217000},{"_id":"source/images/code_bg.png","hash":"c34acd76f73ef68d62c031856bd627ffac9378f3","modified":1405218417000},{"_id":"themes/jacman/languages/zh-CN.yml","hash":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1459925217000},{"_id":"themes/jacman/languages/default.yml","hash":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1459925217000},{"_id":"themes/jacman/languages/zh-TW.yml","hash":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1459925217000},{"_id":"themes/jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1459925217000},{"_id":"themes/jacman/layout/layout.ejs","hash":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1459925217000},{"_id":"themes/jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1459925217000},{"_id":"themes/jacman/layout/index.ejs","hash":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1459925217000},{"_id":"themes/jacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1459925217000},{"_id":"themes/jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1459925217000},{"_id":"themes/jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1459925217000},{"_id":"themes/jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1459925217000},{"_id":"themes/jacman/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1459925214000},{"_id":"themes/jacman/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1459925214000},{"_id":"themes/jacman/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1459925214000},{"_id":"themes/jacman/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1459925214000},{"_id":"themes/jacman/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1459925214000},{"_id":"themes/jacman/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1459925214000},{"_id":"themes/jacman/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1459925214000},{"_id":"themes/jacman/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1459925214000},{"_id":"themes/jacman/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1459925214000},{"_id":"themes/jacman/.git/logs/HEAD","hash":"e9481f21ca84b1557cfcb25f542742dbef7dde8e","modified":1459925217000},{"_id":"themes/jacman/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1459925214000},{"_id":"themes/jacman/layout/_partial/article.ejs","hash":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","hash":"c703b0c25139b8a5f8f9d24a334a07905e2b7987","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/archive.ejs","hash":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","hash":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","hash":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/footer.ejs","hash":"4f905bd920782bb08c621389cf1b4d22b875e770","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/head.ejs","hash":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","hash":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/header.ejs","hash":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/search.ejs","hash":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","hash":"c4f527fff0070fbe65919053a16224412317f40d","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","hash":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1459925217000},{"_id":"themes/jacman/layout/_widget/category.ejs","hash":"62c20e9873221eed8d4ebbe408c991746279e7c0","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/totop.ejs","hash":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1459925217000},{"_id":"themes/jacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1459925217000},{"_id":"themes/jacman/layout/_widget/github-card.ejs","hash":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1459925217000},{"_id":"themes/jacman/layout/_widget/douban.ejs","hash":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1459925217000},{"_id":"themes/jacman/layout/_widget/links.ejs","hash":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1459925217000},{"_id":"themes/jacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1459925217000},{"_id":"themes/jacman/layout/_widget/sponsor.ejs","hash":"37dbb8929b0326e97befa298f1de70fe963afd36","modified":1459925217000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","hash":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1459925217000},{"_id":"themes/jacman/layout/_widget/tag.ejs","hash":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1459925217000},{"_id":"themes/jacman/layout/_widget/weixin.ejs","hash":"873ed894fcf0227bcdae906720231308066653c1","modified":1459925217000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1459925217000},{"_id":"themes/jacman/source/css/style.styl","hash":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1459925217000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1459925217000},{"_id":"themes/jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1459925217000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1459925217000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1459925217000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1459925217000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1459925217000},{"_id":"themes/jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1459925217000},{"_id":"themes/jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1459925217000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1459925217000},{"_id":"themes/jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1459925217000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1459925217000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1459925217000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1459925217000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1459925217000},{"_id":"themes/jacman/source/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1459925217000},{"_id":"themes/jacman/source/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1459925217000},{"_id":"themes/jacman/source/img/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1459925217000},{"_id":"themes/jacman/source/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1459925217000},{"_id":"themes/jacman/source/img/favicon.png","hash":"6658b5a8bbe2a31ceea767cdc28faedddd289285","modified":1459925217000},{"_id":"themes/jacman/source/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1459925217000},{"_id":"themes/jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1459925217000},{"_id":"themes/jacman/source/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1459925217000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1459925217000},{"_id":"themes/jacman/source/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1459925217000},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1459925217000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1459925217000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1459925217000},{"_id":"themes/jacman/source/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1459925217000},{"_id":"themes/jacman/source/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1459925217000},{"_id":"themes/jacman/.git/objects/pack/pack-322cf54574e7cfb3cb14b406f8b19f7678f0bfc9.idx","hash":"a8a0373ab9773b25c6143424b9430b1f6c83749b","modified":1459925217000},{"_id":"themes/jacman/.git/refs/heads/master","hash":"a7b1d4c2bb4a314ea7203d8fd674d6f24d8fbc2e","modified":1459925217000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","hash":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","hash":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","hash":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","hash":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","hash":"14a40545bde669af917c6d0d1df6188240a901f8","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","hash":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1459925217000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","hash":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1459925217000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1459925217000},{"_id":"themes/jacman/source/css/_base/font.styl","hash":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1459925217000},{"_id":"themes/jacman/source/css/_base/public.styl","hash":"f016180726019927b9a835ed01e04d153f27a149","modified":1459925217000},{"_id":"themes/jacman/source/css/_partial/aside.styl","hash":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1459925217000},{"_id":"themes/jacman/source/css/_base/variable.styl","hash":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1459925217000},{"_id":"themes/jacman/source/css/_partial/article.styl","hash":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1459925217000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1459925217000},{"_id":"themes/jacman/source/css/_partial/footer.styl","hash":"fbd8d10e6dbf8c94bd09aa0fb456f23b2f02a9ea","modified":1459925217000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","hash":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1459925217000},{"_id":"themes/jacman/source/css/_partial/header.styl","hash":"5ea1c28a19da709af4619e0ffcbd5261c3d54669","modified":1459925217000},{"_id":"themes/jacman/source/css/_partial/helper.styl","hash":"1136600932b97534b88465bf05ef313630b2de3d","modified":1459925217000},{"_id":"themes/jacman/source/css/_partial/index.styl","hash":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1459925217000},{"_id":"themes/jacman/source/css/_partial/totop.styl","hash":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1459925217000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1459925217000},{"_id":"themes/jacman/.git/logs/refs/heads/master","hash":"e9481f21ca84b1557cfcb25f542742dbef7dde8e","modified":1459925217000},{"_id":"themes/jacman/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1459925217000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","hash":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1459925217000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","hash":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1459925217000},{"_id":"themes/jacman/.git/logs/refs/remotes/origin/HEAD","hash":"e9481f21ca84b1557cfcb25f542742dbef7dde8e","modified":1459925217000},{"_id":"themes/jacman/.git/objects/pack/pack-322cf54574e7cfb3cb14b406f8b19f7678f0bfc9.pack","hash":"f9f7416e7fd76af4d98d593ef35a55f8e1c1185a","modified":1459925217000},{"_id":"public/2016/03/06/2016-03-06-[","hash":"4e432129f147c4a1399973441599ae8e095facbd","modified":1459925235630},{"_id":"public/2014/08/09/2014-08-09-zhuang-ji-ji-lu/index.html","hash":"3ea0b95df17100522359564659420d005238923f","modified":1459925235630},{"_id":"public/2014/07/16/2014-07-16-hui-ji-na-xie-wei-lai-ke-neng-hui-bian-hua-de-swiftgong-neng/index.html","hash":"766bff10fb9282f85ecffec939de81c3511bb7a5","modified":1459925235630},{"_id":"public/archives/index.html","hash":"0250e7931a993a4ec7c64a3a8488062d519767a9","modified":1459925235630},{"_id":"public/archives/2014/index.html","hash":"b81ab5d311482bd334a8ac6e438cb2eae6fb5ca7","modified":1459925235630},{"_id":"public/archives/2014/07/index.html","hash":"6da2872b9c20a6a0e419c30efaeb90283d27080a","modified":1459925235630},{"_id":"public/archives/2014/08/index.html","hash":"95d79f0ec71d47b34eaf16ebff55ab93df2ca2bf","modified":1459925235630},{"_id":"public/archives/2014/09/index.html","hash":"0f6ec5a46a2caff5887b5244c4f2b9687e1f2773","modified":1459925235630},{"_id":"public/archives/2016/index.html","hash":"0c4e833ce4242c13e77b0008fca41a2e6f7ac593","modified":1459925235630},{"_id":"public/archives/2016/03/index.html","hash":"6c60d43bdd44413328ea8a2e894627a589f74436","modified":1459925235631},{"_id":"public/categories/Swift/index.html","hash":"2044ce4a7bdbbe0160425156557005f52d4ae374","modified":1459925235631},{"_id":"public/categories/翻译/index.html","hash":"39cb1bfca56c45dc0663b4eedd1e262385f9cc39","modified":1459925235631},{"_id":"public/index.html","hash":"990157eb091b956a308adc01250dc556c40a000c","modified":1459925235631},{"_id":"public/2014/09/08/2014-09-08-raywenderlich-dot-com-swiftfeng-ge-zhi-nan/index.html","hash":"a0451eeafecae8a04f0c4051eac1d9aef3119156","modified":1459925235631},{"_id":"public/2014/09/02/2014-09-02-cong-objective-czhuan-yi-dao-xu-yao-zhu-yi-de-di-fang/index.html","hash":"cd810c6015fb450f42291508052cc92de07ae77f","modified":1459925235631},{"_id":"public/2014/08/31/2014-08-31-swiftde-zhi-lei-xing-he-yin-yong-lei-xing-de-chai-bie/index.html","hash":"cd5521dc360051612ac764d5a425e88a2f277adf","modified":1459925235631},{"_id":"public/images/bird_32_gray.png","hash":"55345ff7370047a6b825dd235c9ce201545a0952","modified":1459925235643},{"_id":"public/images/bird_32_gray_fail.png","hash":"0c30b159e4cbb7e8a1ad826be537fc4bd79b0a8f","modified":1459925235643},{"_id":"public/images/line-tile.png","hash":"a86a5d70fb0024dd295b85ea9058b43c1c5f25d3","modified":1459925235643},{"_id":"public/images/noise.png","hash":"a839ae391fbbb0a1a2b22f8aba1d8ae2a702ef34","modified":1459925235643},{"_id":"public/images/rss.png","hash":"d61fc1ccc66f081002b15532f66e054147d5f2fb","modified":1459925235643},{"_id":"public/images/email.png","hash":"2a5d251567fabcad68fa596ebaf1508296524930","modified":1459925235643},{"_id":"public/images/search.png","hash":"3c0178651f38bff462d4feb927e4f4df87b0f9d0","modified":1459925235643},{"_id":"public/images/dotted-border.png","hash":"347784b401d0d38acf5e3b6d06a90346a16a8e8c","modified":1459925235643},{"_id":"public/images/code_bg.png","hash":"c34acd76f73ef68d62c031856bd627ffac9378f3","modified":1459925235643},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1459925235643},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1459925235643},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1459925235643},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1459925235643},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1459925235643},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1459925235643},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1459925235643},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1459925235643},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1459925235643},{"_id":"public/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1459925235644},{"_id":"public/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1459925235644},{"_id":"public/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1459925235644},{"_id":"public/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1459925235644},{"_id":"public/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1459925235644},{"_id":"public/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1459925235644},{"_id":"public/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1459925235644},{"_id":"public/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1459925235644},{"_id":"public/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1459925235644},{"_id":"public/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1459925235644},{"_id":"public/img/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1459925235644},{"_id":"public/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1459925235644},{"_id":"public/img/favicon.png","hash":"6658b5a8bbe2a31ceea767cdc28faedddd289285","modified":1459925235644},{"_id":"public/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1459925235644},{"_id":"public/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1459925235644},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1459925235645},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1459925235645},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1459925235645},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1459925235645},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1459925236631},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1459925236633},{"_id":"public/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1459925236634},{"_id":"public/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1459925236634},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1459925236638},{"_id":"public/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1459925236638},{"_id":"public/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1459925236638},{"_id":"public/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1459925236638},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1459925236638},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1459925236638},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1459925236638},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1459925236638},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1459925236638},{"_id":"public/css/style.css","hash":"e63c833fa5d7a87c951a93fb6ffdb4de71ea6c6e","modified":1459925236638},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1459925236638},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1459925236638},{"_id":"public/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1459925236638},{"_id":"public/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1459925236638},{"_id":"public/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1459925236644}],"Category":[{"name":"Swift","_id":"cimohsgph0002sqph5k3duqlr"},{"name":"翻译","_id":"cimohsgpu0008sqphcleuyx8q"}],"Data":[],"Page":[],"Post":[{"layout":"post","title":"汇集那些未来可能会变化的Swift功能","date":"2014-07-16T06:42:25.000Z","comments":1,"_content":"\n\n\nSwift InFlux(https://github.com/ksm/SwiftInFlux)","source":"_posts/2014-07-16-hui-ji-na-xie-wei-lai-ke-neng-hui-bian-hua-de-swiftgong-neng.markdown","raw":"---\nlayout: post\ntitle: \"汇集那些未来可能会变化的Swift功能\"\ndate: 2014-07-16 14:42:25 +0800\ncomments: true\ncategories: Swift\n---\n\n\n\nSwift InFlux(https://github.com/ksm/SwiftInFlux)","slug":"2014-07-16-hui-ji-na-xie-wei-lai-ke-neng-hui-bian-hua-de-swiftgong-neng","published":1,"updated":"2014-07-16T06:54:32.000Z","photos":[],"link":"","_id":"cimohsgp80000sqph9guirsqp","content":"<p>Swift InFlux(<a href=\"https://github.com/ksm/SwiftInFlux\" target=\"_blank\" rel=\"external\">https://github.com/ksm/SwiftInFlux</a>)</p>\n","excerpt":"","more":"<p>Swift InFlux(<a href=\"https://github.com/ksm/SwiftInFlux\">https://github.com/ksm/SwiftInFlux</a>)</p>\n"},{"layout":"post","title":"装机记录","date":"2014-08-09T01:36:11.000Z","comments":1,"_content":"***\n#### GUI安装\n首先进入AppStore升级系统，然后通过AppStore的”Purchases”页面，重新安装以前购买过的应用，再通过网页下载输入法、Resizer、PS等\n***\n#### 命令行安装\t\n**安装homebrew**\n\n\truby -e \"$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)\"\n\t\n安装完成后别忘了执行: \n\n\tbrew doctor\n\t\n然后可以用brew安装git、wget等\n\n\tbrew install git\n\tbrew install wget\n**brew cask**\n\n还可以使用brew cask来安装应用，首先安装cask:\n\n\tbrew tap phinze/cask\n\tbrew install brew-cask\n\t\n接下来可以安装你需要的软件，例如：\n\n\tbrew cask install google-chrome\n\tbrew cask install sublime-text\n\tbrew cask install mou\n\tbrew cask install sourcetree\t\n***\n**安装oh-my-zsh**\n\n\tcurl -L http://install.ohmyz.sh | sh\n安装完成之后，执行：\n\n\tsubl ~/.zshrc\n\t\n然后把以下这行注释启用：export LANG=en_US.UTF-8 ，否则命令行中的中文可能会乱码。\n你也可以给一些常用命令加上别名，例如：\n\n\talias gs='git status'\n\talias guod='git pull origin develop'\n\talias gpod='git push origin develop'\n***\n**安装CocoaPods**\n\n\tsudo gem install cocoapods\n\t\n然后执行\n\n\t pod setup\n\t \n这是建立pod索引的过程，可能等待比较长时间，建议翻墙\n***\n**安装Alcatraz(Xcode插件管理包)**\n\n\tcurl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh\n\t\n***\n**安装Rvm**\n\t\n\tcurl -L https://get.rvm.io | bash -s stable --ruby\n\t\n由于我的博客使用Octopress搭建，所以安装bundler: \n\n\tgem install bundler\n\tbundle install","source":"_posts/2014-08-09-zhuang-ji-ji-lu.markdown","raw":"---\nlayout: post\ntitle: \"装机记录\"\ndate: 2014-08-09 09:36:11 +0800\ncomments: true\ncategories: \n---\n***\n#### GUI安装\n首先进入AppStore升级系统，然后通过AppStore的”Purchases”页面，重新安装以前购买过的应用，再通过网页下载输入法、Resizer、PS等\n***\n#### 命令行安装\t\n**安装homebrew**\n\n\truby -e \"$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)\"\n\t\n安装完成后别忘了执行: \n\n\tbrew doctor\n\t\n然后可以用brew安装git、wget等\n\n\tbrew install git\n\tbrew install wget\n**brew cask**\n\n还可以使用brew cask来安装应用，首先安装cask:\n\n\tbrew tap phinze/cask\n\tbrew install brew-cask\n\t\n接下来可以安装你需要的软件，例如：\n\n\tbrew cask install google-chrome\n\tbrew cask install sublime-text\n\tbrew cask install mou\n\tbrew cask install sourcetree\t\n***\n**安装oh-my-zsh**\n\n\tcurl -L http://install.ohmyz.sh | sh\n安装完成之后，执行：\n\n\tsubl ~/.zshrc\n\t\n然后把以下这行注释启用：export LANG=en_US.UTF-8 ，否则命令行中的中文可能会乱码。\n你也可以给一些常用命令加上别名，例如：\n\n\talias gs='git status'\n\talias guod='git pull origin develop'\n\talias gpod='git push origin develop'\n***\n**安装CocoaPods**\n\n\tsudo gem install cocoapods\n\t\n然后执行\n\n\t pod setup\n\t \n这是建立pod索引的过程，可能等待比较长时间，建议翻墙\n***\n**安装Alcatraz(Xcode插件管理包)**\n\n\tcurl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh\n\t\n***\n**安装Rvm**\n\t\n\tcurl -L https://get.rvm.io | bash -s stable --ruby\n\t\n由于我的博客使用Octopress搭建，所以安装bundler: \n\n\tgem install bundler\n\tbundle install","slug":"2014-08-09-zhuang-ji-ji-lu","published":1,"updated":"2014-10-19T14:37:34.000Z","photos":[],"link":"","_id":"cimohsgpe0001sqphbdc3u5ua","content":"<hr>\n<h4 id=\"GUI安装\"><a href=\"#GUI安装\" class=\"headerlink\" title=\"GUI安装\"></a>GUI安装</h4><p>首先进入AppStore升级系统，然后通过AppStore的”Purchases”页面，重新安装以前购买过的应用，再通过网页下载输入法、Resizer、PS等</p>\n<hr>\n<h4 id=\"命令行安装\"><a href=\"#命令行安装\" class=\"headerlink\" title=\"命令行安装\"></a>命令行安装</h4><p><strong>安装homebrew</strong></p>\n<pre><code>ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot;\n</code></pre><p>安装完成后别忘了执行: </p>\n<pre><code>brew doctor\n</code></pre><p>然后可以用brew安装git、wget等</p>\n<pre><code>brew install git\nbrew install wget\n</code></pre><p><strong>brew cask</strong></p>\n<p>还可以使用brew cask来安装应用，首先安装cask:</p>\n<pre><code>brew tap phinze/cask\nbrew install brew-cask\n</code></pre><p>接下来可以安装你需要的软件，例如：</p>\n<pre><code>brew cask install google-chrome\nbrew cask install sublime-text\nbrew cask install mou\nbrew cask install sourcetree    \n</code></pre><hr>\n<p><strong>安装oh-my-zsh</strong></p>\n<pre><code>curl -L http://install.ohmyz.sh | sh\n</code></pre><p>安装完成之后，执行：</p>\n<pre><code>subl ~/.zshrc\n</code></pre><p>然后把以下这行注释启用：export LANG=en_US.UTF-8 ，否则命令行中的中文可能会乱码。<br>你也可以给一些常用命令加上别名，例如：</p>\n<pre><code>alias gs=&apos;git status&apos;\nalias guod=&apos;git pull origin develop&apos;\nalias gpod=&apos;git push origin develop&apos;\n</code></pre><hr>\n<p><strong>安装CocoaPods</strong></p>\n<pre><code>sudo gem install cocoapods\n</code></pre><p>然后执行</p>\n<pre><code>pod setup\n</code></pre><p>这是建立pod索引的过程，可能等待比较长时间，建议翻墙</p>\n<hr>\n<p><strong>安装Alcatraz(Xcode插件管理包)</strong></p>\n<pre><code>curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh\n</code></pre><hr>\n<p><strong>安装Rvm</strong></p>\n<pre><code>curl -L https://get.rvm.io | bash -s stable --ruby\n</code></pre><p>由于我的博客使用Octopress搭建，所以安装bundler: </p>\n<pre><code>gem install bundler\nbundle install\n</code></pre>","excerpt":"","more":"<hr>\n<h4 id=\"GUI安装\"><a href=\"#GUI安装\" class=\"headerlink\" title=\"GUI安装\"></a>GUI安装</h4><p>首先进入AppStore升级系统，然后通过AppStore的”Purchases”页面，重新安装以前购买过的应用，再通过网页下载输入法、Resizer、PS等</p>\n<hr>\n<h4 id=\"命令行安装\"><a href=\"#命令行安装\" class=\"headerlink\" title=\"命令行安装\"></a>命令行安装</h4><p><strong>安装homebrew</strong></p>\n<pre><code>ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot;\n</code></pre><p>安装完成后别忘了执行: </p>\n<pre><code>brew doctor\n</code></pre><p>然后可以用brew安装git、wget等</p>\n<pre><code>brew install git\nbrew install wget\n</code></pre><p><strong>brew cask</strong></p>\n<p>还可以使用brew cask来安装应用，首先安装cask:</p>\n<pre><code>brew tap phinze/cask\nbrew install brew-cask\n</code></pre><p>接下来可以安装你需要的软件，例如：</p>\n<pre><code>brew cask install google-chrome\nbrew cask install sublime-text\nbrew cask install mou\nbrew cask install sourcetree    \n</code></pre><hr>\n<p><strong>安装oh-my-zsh</strong></p>\n<pre><code>curl -L http://install.ohmyz.sh | sh\n</code></pre><p>安装完成之后，执行：</p>\n<pre><code>subl ~/.zshrc\n</code></pre><p>然后把以下这行注释启用：export LANG=en_US.UTF-8 ，否则命令行中的中文可能会乱码。<br>你也可以给一些常用命令加上别名，例如：</p>\n<pre><code>alias gs=&apos;git status&apos;\nalias guod=&apos;git pull origin develop&apos;\nalias gpod=&apos;git push origin develop&apos;\n</code></pre><hr>\n<p><strong>安装CocoaPods</strong></p>\n<pre><code>sudo gem install cocoapods\n</code></pre><p>然后执行</p>\n<pre><code>pod setup\n</code></pre><p>这是建立pod索引的过程，可能等待比较长时间，建议翻墙</p>\n<hr>\n<p><strong>安装Alcatraz(Xcode插件管理包)</strong></p>\n<pre><code>curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh\n</code></pre><hr>\n<p><strong>安装Rvm</strong></p>\n<pre><code>curl -L https://get.rvm.io | bash -s stable --ruby\n</code></pre><p>由于我的博客使用Octopress搭建，所以安装bundler: </p>\n<pre><code>gem install bundler\nbundle install\n</code></pre>"},{"layout":"post","title":"Swift的值类型和引用类型的差别","date":"2014-08-31T11:49:25.000Z","comments":1,"_content":"Swift的值分两种类型：值类型和引用类型。前者的实例保存着数据相同且各自独立的副本，像struct、enum和tuple这些；而后者的实例保存同一份数据，如class。这文章我们来挖掘这两种类型各自的优点以及思考开发中要如何选用\n\n### 有何不同\n值类型的最大特点是复制，无论是初始化还是传值，它都会复制出另一个相同数据的对象出来：\n\n```swift\n// Value type example\nstruct S { var data: Int = -1 }\n\tvar a = S()\n\tvar b = a\t\t\t\t\t\t// a is copied to b\n\ta.data = 42\t\t\t\t\t\t// Changes a, not b\n\tprintln(\"\\(a.data), \\(b.data)\")\t// prints \"42, -1\"\n```\n\t\n而引用类型的赋值，则会新建另一个对象，并指向相同的共享数据地址:\n```swift\n// Reference type example\nclass C { var data: Int = -1 }\nvar x = C()\nvar y = x\t\t\t\t\t\t// x is copied to y\nx.data = 42\t\t\t\t\t\t// changes the instance referred to by x (and y)\nprintln(\"\\(x.data), \\(y.data)\")\t// prints \"42, 42\"\n```\t\n\n### 保证数据突变的安全性\n这是选择值类型的其中一个原因。当你获取到唯一的实例对象时，妈妈再也不用再担心你的数据在背后被偷偷修改了。尤其是在多线程环境，有可能某线程背着你改了数据而出现些难以debug的问题。\n\n按道理这个不同点会发生在你改变数据那一刻，所以有一种情况下值类型和引用类型是一样的————对象无法写入时。\n\n你可能会想当class为完全不可变时也会有这优点，这样我们可以简单地使用熟悉的Cocoa NSObject对象同时享有值类型的优点。现在，你可以用Swift通过immutable properties来写出immutable class，事实上，很多常用Cocoa class如NSURL都已被设计成immutable class。但是要注意，这种immutable class不是值类型。\n\n### 如何选用\n当你想新建一种类型，你如果选择用值类型还是引用类型呢？如果想你的类型和Cocoa有更有的相容性建议用class，其他情况可以参考如下几条指引：\n\n使用值类型：\n\n*   使用 == 来比较数据是否一致\n*   你希望对象有独立状态\n*   数据将会被多线程使用\n\n使用引用类型：\n\n*   使用 === 来比较对象一致\n*   你希望对象的数据是共享的、可变的\n\n\n在Swift的世界，Array、String和Dictionary都是值类型，他们就像C语言的int类型，保持着相对独立的数据，你不需要显式声明copy来避免数据被偷偷修改，更重要的是你可以安全地线程间传值而不需要synchronization。得益与这一特性，这可以助你用Swift写出更安全可控的代码。","source":"_posts/2014-08-31-swiftde-zhi-lei-xing-he-yin-yong-lei-xing-de-chai-bie.markdown","raw":"---\nlayout: post\ntitle: \"Swift的值类型和引用类型的差别\"\ndate: 2014-08-31 19:49:25 +0800\ncomments: true\ncategories: \n---\nSwift的值分两种类型：值类型和引用类型。前者的实例保存着数据相同且各自独立的副本，像struct、enum和tuple这些；而后者的实例保存同一份数据，如class。这文章我们来挖掘这两种类型各自的优点以及思考开发中要如何选用\n\n### 有何不同\n值类型的最大特点是复制，无论是初始化还是传值，它都会复制出另一个相同数据的对象出来：\n\n```swift\n// Value type example\nstruct S { var data: Int = -1 }\n\tvar a = S()\n\tvar b = a\t\t\t\t\t\t// a is copied to b\n\ta.data = 42\t\t\t\t\t\t// Changes a, not b\n\tprintln(\"\\(a.data), \\(b.data)\")\t// prints \"42, -1\"\n```\n\t\n而引用类型的赋值，则会新建另一个对象，并指向相同的共享数据地址:\n```swift\n// Reference type example\nclass C { var data: Int = -1 }\nvar x = C()\nvar y = x\t\t\t\t\t\t// x is copied to y\nx.data = 42\t\t\t\t\t\t// changes the instance referred to by x (and y)\nprintln(\"\\(x.data), \\(y.data)\")\t// prints \"42, 42\"\n```\t\n\n### 保证数据突变的安全性\n这是选择值类型的其中一个原因。当你获取到唯一的实例对象时，妈妈再也不用再担心你的数据在背后被偷偷修改了。尤其是在多线程环境，有可能某线程背着你改了数据而出现些难以debug的问题。\n\n按道理这个不同点会发生在你改变数据那一刻，所以有一种情况下值类型和引用类型是一样的————对象无法写入时。\n\n你可能会想当class为完全不可变时也会有这优点，这样我们可以简单地使用熟悉的Cocoa NSObject对象同时享有值类型的优点。现在，你可以用Swift通过immutable properties来写出immutable class，事实上，很多常用Cocoa class如NSURL都已被设计成immutable class。但是要注意，这种immutable class不是值类型。\n\n### 如何选用\n当你想新建一种类型，你如果选择用值类型还是引用类型呢？如果想你的类型和Cocoa有更有的相容性建议用class，其他情况可以参考如下几条指引：\n\n使用值类型：\n\n*   使用 == 来比较数据是否一致\n*   你希望对象有独立状态\n*   数据将会被多线程使用\n\n使用引用类型：\n\n*   使用 === 来比较对象一致\n*   你希望对象的数据是共享的、可变的\n\n\n在Swift的世界，Array、String和Dictionary都是值类型，他们就像C语言的int类型，保持着相对独立的数据，你不需要显式声明copy来避免数据被偷偷修改，更重要的是你可以安全地线程间传值而不需要synchronization。得益与这一特性，这可以助你用Swift写出更安全可控的代码。","slug":"2014-08-31-swiftde-zhi-lei-xing-he-yin-yong-lei-xing-de-chai-bie","published":1,"updated":"2014-09-08T07:49:26.000Z","photos":[],"link":"","_id":"cimohsgpk0003sqphzcc8x5qn","content":"<p>Swift的值分两种类型：值类型和引用类型。前者的实例保存着数据相同且各自独立的副本，像struct、enum和tuple这些；而后者的实例保存同一份数据，如class。这文章我们来挖掘这两种类型各自的优点以及思考开发中要如何选用</p>\n<h3 id=\"有何不同\"><a href=\"#有何不同\" class=\"headerlink\" title=\"有何不同\"></a>有何不同</h3><p>值类型的最大特点是复制，无论是初始化还是传值，它都会复制出另一个相同数据的对象出来：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Value type example</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S</span> </span>&#123; <span class=\"keyword\">var</span> data: <span class=\"type\">Int</span> = -<span class=\"number\">1</span> &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"type\">S</span>()</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> b = a\t\t\t\t\t\t<span class=\"comment\">// a is copied to b</span></span><br><span class=\"line\">\ta.data = <span class=\"number\">42</span>\t\t\t\t\t\t<span class=\"comment\">// Changes a, not b</span></span><br><span class=\"line\">\t<span class=\"built_in\">println</span>(<span class=\"string\">\"<span class=\"subst\">\\(a.data)</span>, <span class=\"subst\">\\(b.data)</span>\"</span>)\t<span class=\"comment\">// prints \"42, -1\"</span></span><br></pre></td></tr></table></figure>\n<p>而引用类型的赋值，则会新建另一个对象，并指向相同的共享数据地址:</p>\n<pre><code class=\"swift\"><span class=\"comment\">// Reference type example</span>\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>{ <span class=\"keyword\">var</span> data: <span class=\"type\">Int</span> = -<span class=\"number\">1</span> }\n<span class=\"keyword\">var</span> x = <span class=\"type\">C</span>()\n<span class=\"keyword\">var</span> y = x                        <span class=\"comment\">// x is copied to y</span>\nx.data = <span class=\"number\">42</span>                        <span class=\"comment\">// changes the instance referred to by x (and y)</span>\n<span class=\"built_in\">println</span>(<span class=\"string\">\"<span class=\"subst\">\\(x.data)</span>, <span class=\"subst\">\\(y.data)</span>\"</span>)    <span class=\"comment\">// prints \"42, 42\"</span>\n</code></pre>\n<h3 id=\"保证数据突变的安全性\"><a href=\"#保证数据突变的安全性\" class=\"headerlink\" title=\"保证数据突变的安全性\"></a>保证数据突变的安全性</h3><p>这是选择值类型的其中一个原因。当你获取到唯一的实例对象时，妈妈再也不用再担心你的数据在背后被偷偷修改了。尤其是在多线程环境，有可能某线程背着你改了数据而出现些难以debug的问题。</p>\n<p>按道理这个不同点会发生在你改变数据那一刻，所以有一种情况下值类型和引用类型是一样的————对象无法写入时。</p>\n<p>你可能会想当class为完全不可变时也会有这优点，这样我们可以简单地使用熟悉的Cocoa NSObject对象同时享有值类型的优点。现在，你可以用Swift通过immutable properties来写出immutable class，事实上，很多常用Cocoa class如NSURL都已被设计成immutable class。但是要注意，这种immutable class不是值类型。</p>\n<h3 id=\"如何选用\"><a href=\"#如何选用\" class=\"headerlink\" title=\"如何选用\"></a>如何选用</h3><p>当你想新建一种类型，你如果选择用值类型还是引用类型呢？如果想你的类型和Cocoa有更有的相容性建议用class，其他情况可以参考如下几条指引：</p>\n<p>使用值类型：</p>\n<ul>\n<li>使用 == 来比较数据是否一致</li>\n<li>你希望对象有独立状态</li>\n<li>数据将会被多线程使用</li>\n</ul>\n<p>使用引用类型：</p>\n<ul>\n<li>使用 === 来比较对象一致</li>\n<li>你希望对象的数据是共享的、可变的</li>\n</ul>\n<p>在Swift的世界，Array、String和Dictionary都是值类型，他们就像C语言的int类型，保持着相对独立的数据，你不需要显式声明copy来避免数据被偷偷修改，更重要的是你可以安全地线程间传值而不需要synchronization。得益与这一特性，这可以助你用Swift写出更安全可控的代码。</p>\n","excerpt":"","more":"<p>Swift的值分两种类型：值类型和引用类型。前者的实例保存着数据相同且各自独立的副本，像struct、enum和tuple这些；而后者的实例保存同一份数据，如class。这文章我们来挖掘这两种类型各自的优点以及思考开发中要如何选用</p>\n<h3 id=\"有何不同\"><a href=\"#有何不同\" class=\"headerlink\" title=\"有何不同\"></a>有何不同</h3><p>值类型的最大特点是复制，无论是初始化还是传值，它都会复制出另一个相同数据的对象出来：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Value type example</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S</span> </span>&#123; <span class=\"keyword\">var</span> data: <span class=\"type\">Int</span> = -<span class=\"number\">1</span> &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"type\">S</span>()</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> b = a\t\t\t\t\t\t<span class=\"comment\">// a is copied to b</span></span><br><span class=\"line\">\ta.data = <span class=\"number\">42</span>\t\t\t\t\t\t<span class=\"comment\">// Changes a, not b</span></span><br><span class=\"line\">\t<span class=\"built_in\">println</span>(<span class=\"string\">\"<span class=\"subst\">\\(a.data)</span>, <span class=\"subst\">\\(b.data)</span>\"</span>)\t<span class=\"comment\">// prints \"42, -1\"</span></span><br></pre></td></tr></table></figure>\n<p>而引用类型的赋值，则会新建另一个对象，并指向相同的共享数据地址:</p>\n<pre><code class=\"swift\"><span class=\"comment\">// Reference type example</span>\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>{ <span class=\"keyword\">var</span> data: <span class=\"type\">Int</span> = -<span class=\"number\">1</span> }\n<span class=\"keyword\">var</span> x = <span class=\"type\">C</span>()\n<span class=\"keyword\">var</span> y = x                        <span class=\"comment\">// x is copied to y</span>\nx.data = <span class=\"number\">42</span>                        <span class=\"comment\">// changes the instance referred to by x (and y)</span>\n<span class=\"built_in\">println</span>(<span class=\"string\">\"<span class=\"subst\">\\(x.data)</span>, <span class=\"subst\">\\(y.data)</span>\"</span>)    <span class=\"comment\">// prints \"42, 42\"</span>\n</code></pre>\n<h3 id=\"保证数据突变的安全性\"><a href=\"#保证数据突变的安全性\" class=\"headerlink\" title=\"保证数据突变的安全性\"></a>保证数据突变的安全性</h3><p>这是选择值类型的其中一个原因。当你获取到唯一的实例对象时，妈妈再也不用再担心你的数据在背后被偷偷修改了。尤其是在多线程环境，有可能某线程背着你改了数据而出现些难以debug的问题。</p>\n<p>按道理这个不同点会发生在你改变数据那一刻，所以有一种情况下值类型和引用类型是一样的————对象无法写入时。</p>\n<p>你可能会想当class为完全不可变时也会有这优点，这样我们可以简单地使用熟悉的Cocoa NSObject对象同时享有值类型的优点。现在，你可以用Swift通过immutable properties来写出immutable class，事实上，很多常用Cocoa class如NSURL都已被设计成immutable class。但是要注意，这种immutable class不是值类型。</p>\n<h3 id=\"如何选用\"><a href=\"#如何选用\" class=\"headerlink\" title=\"如何选用\"></a>如何选用</h3><p>当你想新建一种类型，你如果选择用值类型还是引用类型呢？如果想你的类型和Cocoa有更有的相容性建议用class，其他情况可以参考如下几条指引：</p>\n<p>使用值类型：</p>\n<ul>\n<li>使用 == 来比较数据是否一致</li>\n<li>你希望对象有独立状态</li>\n<li>数据将会被多线程使用</li>\n</ul>\n<p>使用引用类型：</p>\n<ul>\n<li>使用 === 来比较对象一致</li>\n<li>你希望对象的数据是共享的、可变的</li>\n</ul>\n<p>在Swift的世界，Array、String和Dictionary都是值类型，他们就像C语言的int类型，保持着相对独立的数据，你不需要显式声明copy来避免数据被偷偷修改，更重要的是你可以安全地线程间传值而不需要synchronization。得益与这一特性，这可以助你用Swift写出更安全可控的代码。</p>\n"},{"layout":"post","title":"从Objective-C转移到Swift需要注意的地方","date":"2014-09-02T12:41:46.000Z","comments":1,"_content":"我想通过这文章分享一下我从Objective-C转移到Swift过程中的一些想法。我会给你一些提示并讨论相关的陷阱，尽可能去比较两种语言的方法有何不同。废话不多说，马上开始！\n\n### xxx.swift VS xxx.h&xxx.m\n\n第一个要注意的大变化是，Swift不采用interface.h/implementation.m的结构。其实我是非常支持把需要共享的信息放头文件的，这样很安全。而Swift，不再分开头文件与实现文件了，只需要实现我们的class。\n\n自从Xcode6 beta4开始，Swift加入了三个访问权限控制修饰词：\n\n*  private 只能被相同源文件下被访问\n*  internal 只能被当前target下的文件访问\n*  public 可以被属于当前target的module下的所有文件访问\n\n\n三个中internal是默认的，另外对属性加修饰词可以设置只对set方法成效，例如：\n```swift\n\t// 这样对于其他文件是只读不可写了\n\tprivate(set) var UUID: NSUUID\n```\t\n\t\n而当你需要重载声明了public修饰词的方法时，你也必须要加public的:\n```swift\n\tpublic override func isEqual(object: AnyObject?) -> Bool{\n\t\tif let item = object as? ListItem {\n\t\t\treturn self.UUID == item.UUID\n\t\t}\t\n\t}\n```\n### 常量与变量\n在写Objective-C时，我知道有些数据不应该被改变也是比较少用**const**的（请不要耻笑我）。而在Swift，苹果建议开发者更多去思考，能用常量(**let**)，就少用变量(**var**)。这样你只需要专注于如何使你定义的变量发挥作用。\n\n\n### 只写需要的代码\n举个栗子：\n```swift\t\n\tlet wsURL:NSURL = NSURL(string:\"http://wsurl.com\");\n\t<!---->\n\tlet wsURL = NSURL(string:\"http://wsurl.com\") \n```\t\n\t\n经过两周训练写Swift，我强迫自己去掉每行代码的分号。最后我感觉整个人都舒服了，然后我经常写Objective-C漏掉了分号，呵呵。\n\n**Type inference**是指通过赋值时的声明来推断出实例的类型，这种方便的写法使得习惯了冗长派语言（如Objective-C）的我有点措手不及。\n\n另一种情况是在if里买不一定需要括号：\n```swift\n\tif (a > b) {}\n\t<!---->\n\tif a > b {}\n```\t\n\t\n以上是一样的，另外如果你要在if里面赋值是不能加括号的：\n```swift\n\tif (let x = data){} //Error!\n\tif let x = data{}  //OK!\n```\n\n### Optionals\n很多时候函数返回的会是**值**或者**空**，而你会用什么方案来返回这个**空**呢？我会使用**NSNotFound**,**-1**,**0**或**nil**。得益于Optionals，现在**空**有了官方的完整定义，我们只需在数据类型后加问号就行了。\n\n例如：\n\n```swift\n\tclass Car{\n\t    func accelerate(){\n\t        print(\"accelerate\")\n\t    }\n\t}\t\n\tclass Person{\n\t    let name:String\n\t    let car:Car? // Optional value\n\t    init(name:String){\n\t        self.name = name\n\t    }\n\t}\n\t// ACCESSING THE OPTIONAL VALUE ***********\n\tvar Mark = Person(name:\"mark\")\n\t// use optional binding\n\tif let car = Mark.car {\n\t    car.accelerate()\n\t}\n\t// unwrap the value\n\tMark.car?.accelerate()\n```\n在这个例子中，Person有Car被定义成一个Optional。这意味着属性car可以为空，然后我们可以通过Optional binding(if let car =)或者unwrap(car?)来访问到里面的值。\n如果我们定义某属性不为Optional，那么我们必须要设一个值给它，否则编译器就会不高兴了。我们需要决定好class的属性怎样与其它class相互调用，Optional完全改变了我们构思class的方式。\n\n### Optionals Unwrapping\n当你发现Optional很难用时，那是因为你对它还不够了解...\n```swift\t\n\tMark.car?\n```\n建议你把Optional想象成一个封起来的盒子，当你不肯定里面有没有值时，可以在Optional后面加**?**就代表解封，你即可看到里面的值或者是一个空盒子。而你敢肯定里面绝对有值时，可以在后面加**!**就可以直接获取到值了，但这有个风险，程序运行发现跟你断言的不一样就会马上闪退。\n\n### Delegate模式\n写了多年的Objective-C，我们都已习惯了这种模式，下面用Swift实现一个简单的delegate:\n\n```swift\n\t@objc protocol DataReaderDelegate{\n\t    @optional func DataWillRead()\n\t    func DataDidRead()\n\t}\n\tclass DataReader: NSObject {\n\t    var delegate:DataReaderDelegate?\n\t    var data:NSData?\n\t    func buildData(){\n\t        delegate?.DataWillRead?() // Optional method check\n\t        data = _createData()\n\t        delegate?.DataDidRead()       // Required method check\n\t    }\n\t}\n```\t\n以往我们需要用**respondToSelector**来判断对象是否响应这个方法(真心觉得太烦了)，现在有了Optional就可以简化成：\n```swift\n\tdelegate?.DataWillRead?()\n```\n然后就是在另外的class上实现delegate了：\n```swift\n\tclass ViewController: UIViewController, DataReaderDelegate {                     \n\t    override func viewDidLoad() {\n\t        super.viewDidLoad()\n\t        let reader = DataReader()\n\t        reader.delegate = self\n\t    }\n\t    func DataWillRead() {...}\n\t    func DataDidRead() {...}\n\t}\n```\n### Target-Action模式\n另一种常用模式是target-action模式，你会发现写法跟Objective-C差别不大：\n```swift\n\tclass ViewController: UIViewController {  \n\t    @IBOutlet var button:UIButton\n\t    override func viewDidLoad() {\n\t        super.viewDidLoad()\n    \t    button.addTarget(self, action: \"buttonPressed:\", forControlEvents: UIControlEvents.TouchUpInside)\n\t    }\n    \tfunc buttonPressed(sender:UIButton){...}\n\t}\n```\n最大不同在于selector的定义。我们可以直接写用String写成:\n```swift\n\tSelector(\"buttonPressed:\") \n```\n### 单例模式\n无论你喜不喜欢，单例模式仍然是最常用开发设计模式之一。除了结合GDC和dispatch_once来实现之外，我们还可以使用线程安全的**let**实现。\n\t\n\tclass DataReader: NSObject {\n\t    class var sharedReader:DataReader {\n\t        struct Static{\n\t            static let _instance = DataReader()\n\t        }\n\t        return Static._instance\n\t    }\n\t...\n\t}\n\t\n分析一下\n\n1.我们ShareReader可看成包装起来的静态属性；\n2.而真正的静态属性我用struct来封起来不允许别的class修改；\n3._instance是一个常量，它不能被修改成别的值。\n\n使用：\n\n\tDataReader.sharedReader\n\t\n\t\n自从Xcode6 beta4加入了访问修饰词，我们现在可以简单的写成：\n```swift\n\tprivate let _instance = DataReader()\n\tclass DataReader {\n\t    class var sharedReader:DataReader {\n\t        return _instance\n\t    }\n\t}\n```\t\n### 结构体与枚举\nSwift的结构体与枚举有很多强大特性你是在别的语言找不到的。\n\n它们支持写方法：\n```swift\n\tstruct User{\n\t    // Struct properties\n\t    let name:String\n\t    let ID:Int\n\t    // Method!!!\n\t    func sayHello(){\n\t        println(\"I'm \" + self.name + \" my ID is: \\(self.ID)\")\n\t    }\n\t}\n\tlet pamela = User(name: \"Pamela\", ID: 123456)\n\tpamela.sayHello()\n```\t\n可以见到Swift对结构体有默认的initializer。而枚举的语法有很大不同是用了**case**:\n```swift\n\tenum Fruit { \n\t  case orange\n\t  case apple\n\t}\n```\n不再限制与整数：\n```swift\n\tenum Fruit:String { \n\t  case .orange = \"Orange\"\n\t  case .apple = \"Apple\"\n\t}\n```\t\n甚至可以给它定义更多行为：\n```swift\n\tenum Fruit{\n\t    // Available Fruits\n\t    case orange\n\t    case apple\n\t    // Nested type\n\t    struct Vitamin{\n\t        var name:String\n\t    }\n\t    // Compound property\n\t    var mainVitamin:Vitamin {\n\t\t    switch self{\n\t\t\t    case .orange:\n\t\t        return Vitamin(name: \"C\")\n\t\t    case .apple:\n\t\t        return Vitamin(name: \"B\")\n    \t}\n\t    }\n\t} \n\tlet Apple = Fruit.apple\n\tvar Vitamin = Apple.mainVitamin\n```\n这段代码我们加了一个内嵌类型(Vitamin)和一个compound property(mainVitamin)，这样不同的枚举值出来的mainVitamin就不一样了，这功能真赞！\n\n### Blocks VS Closures\n我非常喜欢blocks，一些简单的delegate我都爱用blocks来替代，它灵活、快速、安全。而在Swift里是用Closures来代替Blocks的。它再续了Blocks的优点，简化了语法，令我爱不惜手。\n以下是官方用Closures实现reversed的例子：\n```swift\n\treversed = sort(names, { (s1: String, s2: String) -> Bool in\n\t    return s1 > s2\n\t})\n```\t\n简化成：\n```swift\n\treversed = sort(names, >) \n```\t\n这里我就不详解Closure的语法了，我来说说Closure的**capture values**。在Objective-C我们需要给变量加**__block**才能在block里面修改该外部变量。而用Closure，这不需要，我们能在Closures里访问和修改外部作用域的变量。另外，如果Closure里引用的实例包含或使用了Closure本身，这就会引起**循环引用**:\n```swift\n\tclass Person{\n\t    var age:Int = 0\n\t    @lazy var agePotion: (Int) -> Void = {\n        (agex:Int)->Void in\n\t            self.age += agex\n\t    }\n\t    func modifyAge(agex:Int, modifier:(Int)->Void){\n\t        modifier(agex)\n\t    }   \n\t}\n\tvar Mark:Person? = Person()\n\tMark!.modifyAge(50, Mark!.agePotion)\n\tMark = nil // Memory Leak\n```\t\n看到agePotion里用了self，**循环引用**就发生了，要避免这问题，我们可以用**Capture List**，这会时分配进Closure的实例是weak或者unowned的，写法也很简单，只需在Closure的定义前加上**[unownded self]**，就可以得到一个unowned或者weak的self了。\n```swift\n\t@lazy var agePotion: (Int) -> Void = {\n\t     [unowned self](agex:Int)->Void in\n\t         self.age += agex\n\t}\n```\t\n### Unowned & Weak Reference\n我们知道**weak Reference**在Objective-C的使用，在Swift上也是一样的。那么**unowned reference**又是什么呢？我就举个例子来解析吧。\n\n我来描述一下一个人与他的银行账号的关系：\n\n1.一个人可以有一个银行账号(optional)\n\n2.一个银行账号必须有拥有者(required)\n```swift\n\t//We can describe this relation with code: \n\tclass Person{\n\t    let name:String\n\t    let account:BankAccount!\n\t    init(name:String){\n\t        self.name = name\n\t        self.account = BankAccount(owner: self)\n\t    }\n\t}\n\tclass BankAccount{\n\t    let owner:Person\n\t    init(owner:Person){\n\t        self.owner = owner\n\t    }\n\t}\n```\n这就生成了一个引用循环。一种解决方案是对BankAccount.owner属性添加weak reference。你也可以使用unowned reference，但这个属性就必须要非空了。总结就是**unowned**就只是比**weak**多了一个非空限制而已，其他一样的。\n\n### 最后\n在写Swift的过程中，越来越发现一些有趣的特性，这令我更想多写Swift，期待正式版Xcode 6。","source":"_posts/2014-09-02-cong-objective-czhuan-yi-dao-xu-yao-zhu-yi-de-di-fang.markdown","raw":"---\nlayout: post\ntitle: \"从Objective-C转移到Swift需要注意的地方\"\ndate: 2014-09-02 20:41:46 +0800\ncomments: true\ncategories: \n---\n我想通过这文章分享一下我从Objective-C转移到Swift过程中的一些想法。我会给你一些提示并讨论相关的陷阱，尽可能去比较两种语言的方法有何不同。废话不多说，马上开始！\n\n### xxx.swift VS xxx.h&xxx.m\n\n第一个要注意的大变化是，Swift不采用interface.h/implementation.m的结构。其实我是非常支持把需要共享的信息放头文件的，这样很安全。而Swift，不再分开头文件与实现文件了，只需要实现我们的class。\n\n自从Xcode6 beta4开始，Swift加入了三个访问权限控制修饰词：\n\n*  private 只能被相同源文件下被访问\n*  internal 只能被当前target下的文件访问\n*  public 可以被属于当前target的module下的所有文件访问\n\n\n三个中internal是默认的，另外对属性加修饰词可以设置只对set方法成效，例如：\n```swift\n\t// 这样对于其他文件是只读不可写了\n\tprivate(set) var UUID: NSUUID\n```\t\n\t\n而当你需要重载声明了public修饰词的方法时，你也必须要加public的:\n```swift\n\tpublic override func isEqual(object: AnyObject?) -> Bool{\n\t\tif let item = object as? ListItem {\n\t\t\treturn self.UUID == item.UUID\n\t\t}\t\n\t}\n```\n### 常量与变量\n在写Objective-C时，我知道有些数据不应该被改变也是比较少用**const**的（请不要耻笑我）。而在Swift，苹果建议开发者更多去思考，能用常量(**let**)，就少用变量(**var**)。这样你只需要专注于如何使你定义的变量发挥作用。\n\n\n### 只写需要的代码\n举个栗子：\n```swift\t\n\tlet wsURL:NSURL = NSURL(string:\"http://wsurl.com\");\n\t<!---->\n\tlet wsURL = NSURL(string:\"http://wsurl.com\") \n```\t\n\t\n经过两周训练写Swift，我强迫自己去掉每行代码的分号。最后我感觉整个人都舒服了，然后我经常写Objective-C漏掉了分号，呵呵。\n\n**Type inference**是指通过赋值时的声明来推断出实例的类型，这种方便的写法使得习惯了冗长派语言（如Objective-C）的我有点措手不及。\n\n另一种情况是在if里买不一定需要括号：\n```swift\n\tif (a > b) {}\n\t<!---->\n\tif a > b {}\n```\t\n\t\n以上是一样的，另外如果你要在if里面赋值是不能加括号的：\n```swift\n\tif (let x = data){} //Error!\n\tif let x = data{}  //OK!\n```\n\n### Optionals\n很多时候函数返回的会是**值**或者**空**，而你会用什么方案来返回这个**空**呢？我会使用**NSNotFound**,**-1**,**0**或**nil**。得益于Optionals，现在**空**有了官方的完整定义，我们只需在数据类型后加问号就行了。\n\n例如：\n\n```swift\n\tclass Car{\n\t    func accelerate(){\n\t        print(\"accelerate\")\n\t    }\n\t}\t\n\tclass Person{\n\t    let name:String\n\t    let car:Car? // Optional value\n\t    init(name:String){\n\t        self.name = name\n\t    }\n\t}\n\t// ACCESSING THE OPTIONAL VALUE ***********\n\tvar Mark = Person(name:\"mark\")\n\t// use optional binding\n\tif let car = Mark.car {\n\t    car.accelerate()\n\t}\n\t// unwrap the value\n\tMark.car?.accelerate()\n```\n在这个例子中，Person有Car被定义成一个Optional。这意味着属性car可以为空，然后我们可以通过Optional binding(if let car =)或者unwrap(car?)来访问到里面的值。\n如果我们定义某属性不为Optional，那么我们必须要设一个值给它，否则编译器就会不高兴了。我们需要决定好class的属性怎样与其它class相互调用，Optional完全改变了我们构思class的方式。\n\n### Optionals Unwrapping\n当你发现Optional很难用时，那是因为你对它还不够了解...\n```swift\t\n\tMark.car?\n```\n建议你把Optional想象成一个封起来的盒子，当你不肯定里面有没有值时，可以在Optional后面加**?**就代表解封，你即可看到里面的值或者是一个空盒子。而你敢肯定里面绝对有值时，可以在后面加**!**就可以直接获取到值了，但这有个风险，程序运行发现跟你断言的不一样就会马上闪退。\n\n### Delegate模式\n写了多年的Objective-C，我们都已习惯了这种模式，下面用Swift实现一个简单的delegate:\n\n```swift\n\t@objc protocol DataReaderDelegate{\n\t    @optional func DataWillRead()\n\t    func DataDidRead()\n\t}\n\tclass DataReader: NSObject {\n\t    var delegate:DataReaderDelegate?\n\t    var data:NSData?\n\t    func buildData(){\n\t        delegate?.DataWillRead?() // Optional method check\n\t        data = _createData()\n\t        delegate?.DataDidRead()       // Required method check\n\t    }\n\t}\n```\t\n以往我们需要用**respondToSelector**来判断对象是否响应这个方法(真心觉得太烦了)，现在有了Optional就可以简化成：\n```swift\n\tdelegate?.DataWillRead?()\n```\n然后就是在另外的class上实现delegate了：\n```swift\n\tclass ViewController: UIViewController, DataReaderDelegate {                     \n\t    override func viewDidLoad() {\n\t        super.viewDidLoad()\n\t        let reader = DataReader()\n\t        reader.delegate = self\n\t    }\n\t    func DataWillRead() {...}\n\t    func DataDidRead() {...}\n\t}\n```\n### Target-Action模式\n另一种常用模式是target-action模式，你会发现写法跟Objective-C差别不大：\n```swift\n\tclass ViewController: UIViewController {  \n\t    @IBOutlet var button:UIButton\n\t    override func viewDidLoad() {\n\t        super.viewDidLoad()\n    \t    button.addTarget(self, action: \"buttonPressed:\", forControlEvents: UIControlEvents.TouchUpInside)\n\t    }\n    \tfunc buttonPressed(sender:UIButton){...}\n\t}\n```\n最大不同在于selector的定义。我们可以直接写用String写成:\n```swift\n\tSelector(\"buttonPressed:\") \n```\n### 单例模式\n无论你喜不喜欢，单例模式仍然是最常用开发设计模式之一。除了结合GDC和dispatch_once来实现之外，我们还可以使用线程安全的**let**实现。\n\t\n\tclass DataReader: NSObject {\n\t    class var sharedReader:DataReader {\n\t        struct Static{\n\t            static let _instance = DataReader()\n\t        }\n\t        return Static._instance\n\t    }\n\t...\n\t}\n\t\n分析一下\n\n1.我们ShareReader可看成包装起来的静态属性；\n2.而真正的静态属性我用struct来封起来不允许别的class修改；\n3._instance是一个常量，它不能被修改成别的值。\n\n使用：\n\n\tDataReader.sharedReader\n\t\n\t\n自从Xcode6 beta4加入了访问修饰词，我们现在可以简单的写成：\n```swift\n\tprivate let _instance = DataReader()\n\tclass DataReader {\n\t    class var sharedReader:DataReader {\n\t        return _instance\n\t    }\n\t}\n```\t\n### 结构体与枚举\nSwift的结构体与枚举有很多强大特性你是在别的语言找不到的。\n\n它们支持写方法：\n```swift\n\tstruct User{\n\t    // Struct properties\n\t    let name:String\n\t    let ID:Int\n\t    // Method!!!\n\t    func sayHello(){\n\t        println(\"I'm \" + self.name + \" my ID is: \\(self.ID)\")\n\t    }\n\t}\n\tlet pamela = User(name: \"Pamela\", ID: 123456)\n\tpamela.sayHello()\n```\t\n可以见到Swift对结构体有默认的initializer。而枚举的语法有很大不同是用了**case**:\n```swift\n\tenum Fruit { \n\t  case orange\n\t  case apple\n\t}\n```\n不再限制与整数：\n```swift\n\tenum Fruit:String { \n\t  case .orange = \"Orange\"\n\t  case .apple = \"Apple\"\n\t}\n```\t\n甚至可以给它定义更多行为：\n```swift\n\tenum Fruit{\n\t    // Available Fruits\n\t    case orange\n\t    case apple\n\t    // Nested type\n\t    struct Vitamin{\n\t        var name:String\n\t    }\n\t    // Compound property\n\t    var mainVitamin:Vitamin {\n\t\t    switch self{\n\t\t\t    case .orange:\n\t\t        return Vitamin(name: \"C\")\n\t\t    case .apple:\n\t\t        return Vitamin(name: \"B\")\n    \t}\n\t    }\n\t} \n\tlet Apple = Fruit.apple\n\tvar Vitamin = Apple.mainVitamin\n```\n这段代码我们加了一个内嵌类型(Vitamin)和一个compound property(mainVitamin)，这样不同的枚举值出来的mainVitamin就不一样了，这功能真赞！\n\n### Blocks VS Closures\n我非常喜欢blocks，一些简单的delegate我都爱用blocks来替代，它灵活、快速、安全。而在Swift里是用Closures来代替Blocks的。它再续了Blocks的优点，简化了语法，令我爱不惜手。\n以下是官方用Closures实现reversed的例子：\n```swift\n\treversed = sort(names, { (s1: String, s2: String) -> Bool in\n\t    return s1 > s2\n\t})\n```\t\n简化成：\n```swift\n\treversed = sort(names, >) \n```\t\n这里我就不详解Closure的语法了，我来说说Closure的**capture values**。在Objective-C我们需要给变量加**__block**才能在block里面修改该外部变量。而用Closure，这不需要，我们能在Closures里访问和修改外部作用域的变量。另外，如果Closure里引用的实例包含或使用了Closure本身，这就会引起**循环引用**:\n```swift\n\tclass Person{\n\t    var age:Int = 0\n\t    @lazy var agePotion: (Int) -> Void = {\n        (agex:Int)->Void in\n\t            self.age += agex\n\t    }\n\t    func modifyAge(agex:Int, modifier:(Int)->Void){\n\t        modifier(agex)\n\t    }   \n\t}\n\tvar Mark:Person? = Person()\n\tMark!.modifyAge(50, Mark!.agePotion)\n\tMark = nil // Memory Leak\n```\t\n看到agePotion里用了self，**循环引用**就发生了，要避免这问题，我们可以用**Capture List**，这会时分配进Closure的实例是weak或者unowned的，写法也很简单，只需在Closure的定义前加上**[unownded self]**，就可以得到一个unowned或者weak的self了。\n```swift\n\t@lazy var agePotion: (Int) -> Void = {\n\t     [unowned self](agex:Int)->Void in\n\t         self.age += agex\n\t}\n```\t\n### Unowned & Weak Reference\n我们知道**weak Reference**在Objective-C的使用，在Swift上也是一样的。那么**unowned reference**又是什么呢？我就举个例子来解析吧。\n\n我来描述一下一个人与他的银行账号的关系：\n\n1.一个人可以有一个银行账号(optional)\n\n2.一个银行账号必须有拥有者(required)\n```swift\n\t//We can describe this relation with code: \n\tclass Person{\n\t    let name:String\n\t    let account:BankAccount!\n\t    init(name:String){\n\t        self.name = name\n\t        self.account = BankAccount(owner: self)\n\t    }\n\t}\n\tclass BankAccount{\n\t    let owner:Person\n\t    init(owner:Person){\n\t        self.owner = owner\n\t    }\n\t}\n```\n这就生成了一个引用循环。一种解决方案是对BankAccount.owner属性添加weak reference。你也可以使用unowned reference，但这个属性就必须要非空了。总结就是**unowned**就只是比**weak**多了一个非空限制而已，其他一样的。\n\n### 最后\n在写Swift的过程中，越来越发现一些有趣的特性，这令我更想多写Swift，期待正式版Xcode 6。","slug":"2014-09-02-cong-objective-czhuan-yi-dao-xu-yao-zhu-yi-de-di-fang","published":1,"updated":"2014-09-08T07:57:16.000Z","photos":[],"link":"","_id":"cimohsgpn0004sqphdbwwrmxo","content":"<p>我想通过这文章分享一下我从Objective-C转移到Swift过程中的一些想法。我会给你一些提示并讨论相关的陷阱，尽可能去比较两种语言的方法有何不同。废话不多说，马上开始！</p>\n<h3 id=\"xxx-swift-VS-xxx-h-amp-xxx-m\"><a href=\"#xxx-swift-VS-xxx-h-amp-xxx-m\" class=\"headerlink\" title=\"xxx.swift VS xxx.h&amp;xxx.m\"></a>xxx.swift VS xxx.h&amp;xxx.m</h3><p>第一个要注意的大变化是，Swift不采用interface.h/implementation.m的结构。其实我是非常支持把需要共享的信息放头文件的，这样很安全。而Swift，不再分开头文件与实现文件了，只需要实现我们的class。</p>\n<p>自从Xcode6 beta4开始，Swift加入了三个访问权限控制修饰词：</p>\n<ul>\n<li>private 只能被相同源文件下被访问</li>\n<li>internal 只能被当前target下的文件访问</li>\n<li>public 可以被属于当前target的module下的所有文件访问</li>\n</ul>\n<p>三个中internal是默认的，另外对属性加修饰词可以设置只对set方法成效，例如：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">// 这样对于其他文件是只读不可写了</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span>(<span class=\"keyword\">set</span>) <span class=\"keyword\">var</span> <span class=\"type\">UUID</span>: <span class=\"type\">NSUUID</span></span><br><span class=\"line\">```\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">而当你需要重载声明了<span class=\"keyword\">public</span>修饰词的方法时，你也必须要加<span class=\"keyword\">public</span>的:</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isEqual</span><span class=\"params\">(object: AnyObject?)</span></span> -&gt; <span class=\"type\">Bool</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"keyword\">let</span> item = object <span class=\"keyword\">as</span>? <span class=\"type\">ListItem</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.<span class=\"type\">UUID</span> == item.<span class=\"type\">UUID</span></span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"常量与变量\"><a href=\"#常量与变量\" class=\"headerlink\" title=\"常量与变量\"></a>常量与变量</h3><p>在写Objective-C时，我知道有些数据不应该被改变也是比较少用<strong>const</strong>的（请不要耻笑我）。而在Swift，苹果建议开发者更多去思考，能用常量(<strong>let</strong>)，就少用变量(<strong>var</strong>)。这样你只需要专注于如何使你定义的变量发挥作用。</p>\n<h3 id=\"只写需要的代码\"><a href=\"#只写需要的代码\" class=\"headerlink\" title=\"只写需要的代码\"></a>只写需要的代码</h3><p>举个栗子：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">let</span> wsURL:<span class=\"type\">NSURL</span> = <span class=\"type\">NSURL</span>(string:<span class=\"string\">\"http://wsurl.com\"</span>);</span><br><span class=\"line\">\t&lt;!----&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> wsURL = <span class=\"type\">NSURL</span>(string:<span class=\"string\">\"http://wsurl.com\"</span>) </span><br><span class=\"line\">```\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">经过两周训练写<span class=\"type\">Swift</span>，我强迫自己去掉每行代码的分号。最后我感觉整个人都舒服了，然后我经常写<span class=\"type\">Objective</span>-<span class=\"type\">C</span>漏掉了分号，呵呵。</span><br><span class=\"line\"></span><br><span class=\"line\">**<span class=\"type\">Type</span> inference**是指通过赋值时的声明来推断出实例的类型，这种方便的写法使得习惯了冗长派语言（如<span class=\"type\">Objective</span>-<span class=\"type\">C</span>）的我有点措手不及。</span><br><span class=\"line\"></span><br><span class=\"line\">另一种情况是在<span class=\"keyword\">if</span>里买不一定需要括号：</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a &gt; b) &#123;&#125;</span><br><span class=\"line\">\t&lt;!----&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a &gt; b &#123;&#125;</span><br><span class=\"line\">```\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">以上是一样的，另外如果你要在<span class=\"keyword\">if</span>里面赋值是不能加括号的：</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">let</span> x = data)&#123;&#125; <span class=\"comment\">//Error!</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"keyword\">let</span> x = data&#123;&#125;  <span class=\"comment\">//OK!</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Optionals\"><a href=\"#Optionals\" class=\"headerlink\" title=\"Optionals\"></a>Optionals</h3><p>很多时候函数返回的会是<strong>值</strong>或者<strong>空</strong>，而你会用什么方案来返回这个<strong>空</strong>呢？我会使用<strong>NSNotFound</strong>,<strong>-1</strong>,<strong>0</strong>或<strong>nil</strong>。得益于Optionals，现在<strong>空</strong>有了官方的完整定义，我们只需在数据类型后加问号就行了。</p>\n<p>例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">accelerate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"accelerate\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;\t</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name:<span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> car:<span class=\"type\">Car</span>? <span class=\"comment\">// Optional value</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(name:<span class=\"type\">String</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ACCESSING THE OPTIONAL VALUE ***********</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"type\">Mark</span> = <span class=\"type\">Person</span>(name:<span class=\"string\">\"mark\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// use optional binding</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> car = <span class=\"type\">Mark</span>.car &#123;</span><br><span class=\"line\">    car.accelerate()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// unwrap the value</span></span><br><span class=\"line\"><span class=\"type\">Mark</span>.car?.accelerate()</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，Person有Car被定义成一个Optional。这意味着属性car可以为空，然后我们可以通过Optional binding(if let car =)或者unwrap(car?)来访问到里面的值。<br>如果我们定义某属性不为Optional，那么我们必须要设一个值给它，否则编译器就会不高兴了。我们需要决定好class的属性怎样与其它class相互调用，Optional完全改变了我们构思class的方式。</p>\n<h3 id=\"Optionals-Unwrapping\"><a href=\"#Optionals-Unwrapping\" class=\"headerlink\" title=\"Optionals Unwrapping\"></a>Optionals Unwrapping</h3><p>当你发现Optional很难用时，那是因为你对它还不够了解…<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Mark</span>.car?</span><br></pre></td></tr></table></figure></p>\n<p>建议你把Optional想象成一个封起来的盒子，当你不肯定里面有没有值时，可以在Optional后面加<strong>?</strong>就代表解封，你即可看到里面的值或者是一个空盒子。而你敢肯定里面绝对有值时，可以在后面加<strong>!</strong>就可以直接获取到值了，但这有个风险，程序运行发现跟你断言的不一样就会马上闪退。</p>\n<h3 id=\"Delegate模式\"><a href=\"#Delegate模式\" class=\"headerlink\" title=\"Delegate模式\"></a>Delegate模式</h3><p>写了多年的Objective-C，我们都已习惯了这种模式，下面用Swift实现一个简单的delegate:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"meta\">@objc</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">DataReaderDelegate</span></span>&#123;</span><br><span class=\"line\">\t    @<span class=\"keyword\">optional</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DataWillRead</span><span class=\"params\">()</span></span></span><br><span class=\"line\">\t    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DataDidRead</span><span class=\"params\">()</span></span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataReader</span>: <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> delegate:<span class=\"type\">DataReaderDelegate</span>?</span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> data:<span class=\"type\">NSData</span>?</span><br><span class=\"line\">\t    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t        delegate?.<span class=\"type\">DataWillRead</span>?() <span class=\"comment\">// Optional method check</span></span><br><span class=\"line\">\t        data = _createData()</span><br><span class=\"line\">\t        delegate?.<span class=\"type\">DataDidRead</span>()       <span class=\"comment\">// Required method check</span></span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">```\t</span><br><span class=\"line\">以往我们需要用**respondToSelector**来判断对象是否响应这个方法(真心觉得太烦了)，现在有了<span class=\"type\">Optional</span>就可以简化成：</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\tdelegate?.<span class=\"type\">DataWillRead</span>?()</span><br></pre></td></tr></table></figure>\n<p>然后就是在另外的class上实现delegate了：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">DataReaderDelegate</span> </span>&#123;                     </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> reader = <span class=\"type\">DataReader</span>()</span><br><span class=\"line\">        reader.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DataWillRead</span><span class=\"params\">()</span></span> &#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DataDidRead</span><span class=\"params\">()</span></span> &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Target-Action模式\"><a href=\"#Target-Action模式\" class=\"headerlink\" title=\"Target-Action模式\"></a>Target-Action模式</h3><p>另一种常用模式是target-action模式，你会发现写法跟Objective-C差别不大：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">var</span> button:<span class=\"type\">UIButton</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">   \t    button.addTarget(<span class=\"keyword\">self</span>, action: <span class=\"string\">\"buttonPressed:\"</span>, forControlEvents: <span class=\"type\">UIControlEvents</span>.<span class=\"type\">TouchUpInside</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   \t<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buttonPressed</span><span class=\"params\">(sender:UIButton)</span></span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最大不同在于selector的定义。我们可以直接写用String写成:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Selector</span>(<span class=\"string\">\"buttonPressed:\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>无论你喜不喜欢，单例模式仍然是最常用开发设计模式之一。除了结合GDC和dispatch_once来实现之外，我们还可以使用线程安全的<strong>let</strong>实现。</p>\n<pre><code>class DataReader: NSObject {\n    class var sharedReader:DataReader {\n        struct Static{\n            static let _instance = DataReader()\n        }\n        return Static._instance\n    }\n...\n}\n</code></pre><p>分析一下</p>\n<p>1.我们ShareReader可看成包装起来的静态属性；<br>2.而真正的静态属性我用struct来封起来不允许别的class修改；<br>3._instance是一个常量，它不能被修改成别的值。</p>\n<p>使用：</p>\n<pre><code>DataReader.sharedReader\n</code></pre><p>自从Xcode6 beta4加入了访问修饰词，我们现在可以简单的写成：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">let</span> _instance = <span class=\"type\">DataReader</span>()</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataReader</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">var</span> <span class=\"title\">sharedReader</span>:<span class=\"title\">DataReader</span> </span>&#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> _instance</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">```\t</span><br><span class=\"line\">### 结构体与枚举</span><br><span class=\"line\"><span class=\"type\">Swift</span>的结构体与枚举有很多强大特性你是在别的语言找不到的。</span><br><span class=\"line\"></span><br><span class=\"line\">它们支持写方法：</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// Struct properties</span></span><br><span class=\"line\">\t    <span class=\"keyword\">let</span> name:<span class=\"type\">String</span></span><br><span class=\"line\">\t    <span class=\"keyword\">let</span> <span class=\"type\">ID</span>:<span class=\"type\">Int</span></span><br><span class=\"line\">\t    <span class=\"comment\">// Method!!!</span></span><br><span class=\"line\">\t    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t        <span class=\"built_in\">println</span>(<span class=\"string\">\"I'm \"</span> + <span class=\"keyword\">self</span>.name + <span class=\"string\">\" my ID is: <span class=\"subst\">\\(<span class=\"keyword\">self</span>.ID)</span>\"</span>)</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> pamela = <span class=\"type\">User</span>(name: <span class=\"string\">\"Pamela\"</span>, <span class=\"type\">ID</span>: <span class=\"number\">123456</span>)</span><br><span class=\"line\">\tpamela.sayHello()</span><br><span class=\"line\">```\t</span><br><span class=\"line\">可以见到<span class=\"type\">Swift</span>对结构体有默认的initializer。而枚举的语法有很大不同是用了**<span class=\"keyword\">case</span>**:</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Fruit</span> </span>&#123; </span><br><span class=\"line\">\t  <span class=\"keyword\">case</span> orange</span><br><span class=\"line\">\t  <span class=\"keyword\">case</span> apple</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不再限制与整数：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Fruit</span>:<span class=\"title\">String</span> </span>&#123; </span><br><span class=\"line\">\t  <span class=\"keyword\">case</span> .orange = <span class=\"string\">\"Orange\"</span></span><br><span class=\"line\">\t  <span class=\"keyword\">case</span> .apple = <span class=\"string\">\"Apple\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">```\t</span><br><span class=\"line\">甚至可以给它定义更多行为：</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Fruit</span></span>&#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// Available Fruits</span></span><br><span class=\"line\">\t    <span class=\"keyword\">case</span> orange</span><br><span class=\"line\">\t    <span class=\"keyword\">case</span> apple</span><br><span class=\"line\">\t    <span class=\"comment\">// Nested type</span></span><br><span class=\"line\">\t    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Vitamin</span></span>&#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">var</span> name:<span class=\"type\">String</span></span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    <span class=\"comment\">// Compound property</span></span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> mainVitamin:<span class=\"type\">Vitamin</span> &#123;</span><br><span class=\"line\">\t\t    <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span>&#123;</span><br><span class=\"line\">\t\t\t    <span class=\"keyword\">case</span> .orange:</span><br><span class=\"line\">\t\t        <span class=\"keyword\">return</span> <span class=\"type\">Vitamin</span>(name: <span class=\"string\">\"C\"</span>)</span><br><span class=\"line\">\t\t    <span class=\"keyword\">case</span> .apple:</span><br><span class=\"line\">\t\t        <span class=\"keyword\">return</span> <span class=\"type\">Vitamin</span>(name: <span class=\"string\">\"B\"</span>)</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t<span class=\"keyword\">let</span> <span class=\"type\">Apple</span> = <span class=\"type\">Fruit</span>.apple</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> <span class=\"type\">Vitamin</span> = <span class=\"type\">Apple</span>.mainVitamin</span><br></pre></td></tr></table></figure></p>\n<p>这段代码我们加了一个内嵌类型(Vitamin)和一个compound property(mainVitamin)，这样不同的枚举值出来的mainVitamin就不一样了，这功能真赞！</p>\n<h3 id=\"Blocks-VS-Closures\"><a href=\"#Blocks-VS-Closures\" class=\"headerlink\" title=\"Blocks VS Closures\"></a>Blocks VS Closures</h3><p>我非常喜欢blocks，一些简单的delegate我都爱用blocks来替代，它灵活、快速、安全。而在Swift里是用Closures来代替Blocks的。它再续了Blocks的优点，简化了语法，令我爱不惜手。<br>以下是官方用Closures实现reversed的例子：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\treversed = <span class=\"built_in\">sort</span>(names, &#123; (s1: <span class=\"type\">String</span>, s2: <span class=\"type\">String</span>) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> s1 &gt; s2</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">```\t</span><br><span class=\"line\">简化成：</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\treversed = <span class=\"built_in\">sort</span>(names, &gt;) </span><br><span class=\"line\">```\t</span><br><span class=\"line\">这里我就不详解<span class=\"type\">Closure</span>的语法了，我来说说<span class=\"type\">Closure</span>的**capture values**。在<span class=\"type\">Objective</span>-<span class=\"type\">C</span>我们需要给变量加**__block**才能在block里面修改该外部变量。而用<span class=\"type\">Closure</span>，这不需要，我们能在<span class=\"type\">Closures</span>里访问和修改外部作用域的变量。另外，如果<span class=\"type\">Closure</span>里引用的实例包含或使用了<span class=\"type\">Closure</span>本身，这就会引起**循环引用**:</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> age:<span class=\"type\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">\t    <span class=\"meta\">@lazy</span> <span class=\"keyword\">var</span> agePotion: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Void</span> = &#123;</span><br><span class=\"line\">        (agex:<span class=\"type\">Int</span>)-&gt;<span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">\t            <span class=\"keyword\">self</span>.age += agex</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">modifyAge</span><span class=\"params\">(agex:Int, modifier:<span class=\"params\">(Int)</span></span></span>-&gt;<span class=\"type\">Void</span>)&#123;</span><br><span class=\"line\">\t        modifier(agex)</span><br><span class=\"line\">\t    &#125;   </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> <span class=\"type\">Mark</span>:<span class=\"type\">Person</span>? = <span class=\"type\">Person</span>()</span><br><span class=\"line\">\t<span class=\"type\">Mark</span>!.modifyAge(<span class=\"number\">50</span>, <span class=\"type\">Mark</span>!.agePotion)</span><br><span class=\"line\">\t<span class=\"type\">Mark</span> = <span class=\"literal\">nil</span> <span class=\"comment\">// Memory Leak</span></span><br><span class=\"line\">```\t</span><br><span class=\"line\">看到agePotion里用了<span class=\"keyword\">self</span>，**循环引用**就发生了，要避免这问题，我们可以用**<span class=\"type\">Capture</span> <span class=\"type\">List</span>**，这会时分配进<span class=\"type\">Closure</span>的实例是<span class=\"keyword\">weak</span>或者<span class=\"keyword\">unowned</span>的，写法也很简单，只需在<span class=\"type\">Closure</span>的定义前加上**[unownded <span class=\"keyword\">self</span>]**，就可以得到一个<span class=\"keyword\">unowned</span>或者<span class=\"keyword\">weak</span>的<span class=\"keyword\">self</span>了。</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"meta\">@lazy</span> <span class=\"keyword\">var</span> agePotion: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Void</span> = &#123;</span><br><span class=\"line\">\t     [<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>](agex:<span class=\"type\">Int</span>)-&gt;<span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">\t         <span class=\"keyword\">self</span>.age += agex</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">```\t</span><br><span class=\"line\">### <span class=\"type\">Unowned</span> &amp; <span class=\"type\">Weak</span> <span class=\"type\">Reference</span></span><br><span class=\"line\">我们知道**<span class=\"keyword\">weak</span> <span class=\"type\">Reference</span>**在<span class=\"type\">Objective</span>-<span class=\"type\">C</span>的使用，在<span class=\"type\">Swift</span>上也是一样的。那么**<span class=\"keyword\">unowned</span> reference**又是什么呢？我就举个例子来解析吧。</span><br><span class=\"line\"></span><br><span class=\"line\">我来描述一下一个人与他的银行账号的关系：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>.一个人可以有一个银行账号(<span class=\"keyword\">optional</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>.一个银行账号必须有拥有者(<span class=\"keyword\">required</span>)</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"comment\">//We can describe this relation with code: </span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">let</span> name:<span class=\"type\">String</span></span><br><span class=\"line\">\t    <span class=\"keyword\">let</span> account:<span class=\"type\">BankAccount</span>!</span><br><span class=\"line\">\t    <span class=\"keyword\">init</span>(name:<span class=\"type\">String</span>)&#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">\t        <span class=\"keyword\">self</span>.account = <span class=\"type\">BankAccount</span>(owner: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BankAccount</span></span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">let</span> owner:<span class=\"type\">Person</span></span><br><span class=\"line\">\t    <span class=\"keyword\">init</span>(owner:<span class=\"type\">Person</span>)&#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">self</span>.owner = owner</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这就生成了一个引用循环。一种解决方案是对BankAccount.owner属性添加weak reference。你也可以使用unowned reference，但这个属性就必须要非空了。总结就是<strong>unowned</strong>就只是比<strong>weak</strong>多了一个非空限制而已，其他一样的。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>在写Swift的过程中，越来越发现一些有趣的特性，这令我更想多写Swift，期待正式版Xcode 6。</p>\n","excerpt":"","more":"<p>我想通过这文章分享一下我从Objective-C转移到Swift过程中的一些想法。我会给你一些提示并讨论相关的陷阱，尽可能去比较两种语言的方法有何不同。废话不多说，马上开始！</p>\n<h3 id=\"xxx-swift-VS-xxx-h-amp-xxx-m\"><a href=\"#xxx-swift-VS-xxx-h-amp-xxx-m\" class=\"headerlink\" title=\"xxx.swift VS xxx.h&amp;xxx.m\"></a>xxx.swift VS xxx.h&amp;xxx.m</h3><p>第一个要注意的大变化是，Swift不采用interface.h/implementation.m的结构。其实我是非常支持把需要共享的信息放头文件的，这样很安全。而Swift，不再分开头文件与实现文件了，只需要实现我们的class。</p>\n<p>自从Xcode6 beta4开始，Swift加入了三个访问权限控制修饰词：</p>\n<ul>\n<li>private 只能被相同源文件下被访问</li>\n<li>internal 只能被当前target下的文件访问</li>\n<li>public 可以被属于当前target的module下的所有文件访问</li>\n</ul>\n<p>三个中internal是默认的，另外对属性加修饰词可以设置只对set方法成效，例如：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">// 这样对于其他文件是只读不可写了</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span>(<span class=\"keyword\">set</span>) <span class=\"keyword\">var</span> <span class=\"type\">UUID</span>: <span class=\"type\">NSUUID</span></span><br><span class=\"line\">```\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">而当你需要重载声明了<span class=\"keyword\">public</span>修饰词的方法时，你也必须要加<span class=\"keyword\">public</span>的:</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isEqual</span><span class=\"params\">(object: AnyObject?)</span></span> -&gt; <span class=\"type\">Bool</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"keyword\">let</span> item = object <span class=\"keyword\">as</span>? <span class=\"type\">ListItem</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.<span class=\"type\">UUID</span> == item.<span class=\"type\">UUID</span></span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"常量与变量\"><a href=\"#常量与变量\" class=\"headerlink\" title=\"常量与变量\"></a>常量与变量</h3><p>在写Objective-C时，我知道有些数据不应该被改变也是比较少用<strong>const</strong>的（请不要耻笑我）。而在Swift，苹果建议开发者更多去思考，能用常量(<strong>let</strong>)，就少用变量(<strong>var</strong>)。这样你只需要专注于如何使你定义的变量发挥作用。</p>\n<h3 id=\"只写需要的代码\"><a href=\"#只写需要的代码\" class=\"headerlink\" title=\"只写需要的代码\"></a>只写需要的代码</h3><p>举个栗子：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">let</span> wsURL:<span class=\"type\">NSURL</span> = <span class=\"type\">NSURL</span>(string:<span class=\"string\">\"http://wsurl.com\"</span>);</span><br><span class=\"line\">\t&lt;!----&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> wsURL = <span class=\"type\">NSURL</span>(string:<span class=\"string\">\"http://wsurl.com\"</span>) </span><br><span class=\"line\">```\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">经过两周训练写<span class=\"type\">Swift</span>，我强迫自己去掉每行代码的分号。最后我感觉整个人都舒服了，然后我经常写<span class=\"type\">Objective</span>-<span class=\"type\">C</span>漏掉了分号，呵呵。</span><br><span class=\"line\"></span><br><span class=\"line\">**<span class=\"type\">Type</span> inference**是指通过赋值时的声明来推断出实例的类型，这种方便的写法使得习惯了冗长派语言（如<span class=\"type\">Objective</span>-<span class=\"type\">C</span>）的我有点措手不及。</span><br><span class=\"line\"></span><br><span class=\"line\">另一种情况是在<span class=\"keyword\">if</span>里买不一定需要括号：</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a &gt; b) &#123;&#125;</span><br><span class=\"line\">\t&lt;!----&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a &gt; b &#123;&#125;</span><br><span class=\"line\">```\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">以上是一样的，另外如果你要在<span class=\"keyword\">if</span>里面赋值是不能加括号的：</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">let</span> x = data)&#123;&#125; <span class=\"comment\">//Error!</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"keyword\">let</span> x = data&#123;&#125;  <span class=\"comment\">//OK!</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Optionals\"><a href=\"#Optionals\" class=\"headerlink\" title=\"Optionals\"></a>Optionals</h3><p>很多时候函数返回的会是<strong>值</strong>或者<strong>空</strong>，而你会用什么方案来返回这个<strong>空</strong>呢？我会使用<strong>NSNotFound</strong>,<strong>-1</strong>,<strong>0</strong>或<strong>nil</strong>。得益于Optionals，现在<strong>空</strong>有了官方的完整定义，我们只需在数据类型后加问号就行了。</p>\n<p>例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">accelerate</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"accelerate\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;\t</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> name:<span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> car:<span class=\"type\">Car</span>? <span class=\"comment\">// Optional value</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(name:<span class=\"type\">String</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ACCESSING THE OPTIONAL VALUE ***********</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"type\">Mark</span> = <span class=\"type\">Person</span>(name:<span class=\"string\">\"mark\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// use optional binding</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> car = <span class=\"type\">Mark</span>.car &#123;</span><br><span class=\"line\">    car.accelerate()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// unwrap the value</span></span><br><span class=\"line\"><span class=\"type\">Mark</span>.car?.accelerate()</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，Person有Car被定义成一个Optional。这意味着属性car可以为空，然后我们可以通过Optional binding(if let car =)或者unwrap(car?)来访问到里面的值。<br>如果我们定义某属性不为Optional，那么我们必须要设一个值给它，否则编译器就会不高兴了。我们需要决定好class的属性怎样与其它class相互调用，Optional完全改变了我们构思class的方式。</p>\n<h3 id=\"Optionals-Unwrapping\"><a href=\"#Optionals-Unwrapping\" class=\"headerlink\" title=\"Optionals Unwrapping\"></a>Optionals Unwrapping</h3><p>当你发现Optional很难用时，那是因为你对它还不够了解…<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Mark</span>.car?</span><br></pre></td></tr></table></figure></p>\n<p>建议你把Optional想象成一个封起来的盒子，当你不肯定里面有没有值时，可以在Optional后面加<strong>?</strong>就代表解封，你即可看到里面的值或者是一个空盒子。而你敢肯定里面绝对有值时，可以在后面加<strong>!</strong>就可以直接获取到值了，但这有个风险，程序运行发现跟你断言的不一样就会马上闪退。</p>\n<h3 id=\"Delegate模式\"><a href=\"#Delegate模式\" class=\"headerlink\" title=\"Delegate模式\"></a>Delegate模式</h3><p>写了多年的Objective-C，我们都已习惯了这种模式，下面用Swift实现一个简单的delegate:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"meta\">@objc</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">DataReaderDelegate</span></span>&#123;</span><br><span class=\"line\">\t    @<span class=\"keyword\">optional</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DataWillRead</span><span class=\"params\">()</span></span></span><br><span class=\"line\">\t    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DataDidRead</span><span class=\"params\">()</span></span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataReader</span>: <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> delegate:<span class=\"type\">DataReaderDelegate</span>?</span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> data:<span class=\"type\">NSData</span>?</span><br><span class=\"line\">\t    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t        delegate?.<span class=\"type\">DataWillRead</span>?() <span class=\"comment\">// Optional method check</span></span><br><span class=\"line\">\t        data = _createData()</span><br><span class=\"line\">\t        delegate?.<span class=\"type\">DataDidRead</span>()       <span class=\"comment\">// Required method check</span></span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">```\t</span><br><span class=\"line\">以往我们需要用**respondToSelector**来判断对象是否响应这个方法(真心觉得太烦了)，现在有了<span class=\"type\">Optional</span>就可以简化成：</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\tdelegate?.<span class=\"type\">DataWillRead</span>?()</span><br></pre></td></tr></table></figure>\n<p>然后就是在另外的class上实现delegate了：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">DataReaderDelegate</span> </span>&#123;                     </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> reader = <span class=\"type\">DataReader</span>()</span><br><span class=\"line\">        reader.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DataWillRead</span><span class=\"params\">()</span></span> &#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">DataDidRead</span><span class=\"params\">()</span></span> &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Target-Action模式\"><a href=\"#Target-Action模式\" class=\"headerlink\" title=\"Target-Action模式\"></a>Target-Action模式</h3><p>另一种常用模式是target-action模式，你会发现写法跟Objective-C差别不大：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@IBOutlet</span> <span class=\"keyword\">var</span> button:<span class=\"type\">UIButton</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">   \t    button.addTarget(<span class=\"keyword\">self</span>, action: <span class=\"string\">\"buttonPressed:\"</span>, forControlEvents: <span class=\"type\">UIControlEvents</span>.<span class=\"type\">TouchUpInside</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   \t<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buttonPressed</span><span class=\"params\">(sender:UIButton)</span></span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最大不同在于selector的定义。我们可以直接写用String写成:<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Selector</span>(<span class=\"string\">\"buttonPressed:\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>无论你喜不喜欢，单例模式仍然是最常用开发设计模式之一。除了结合GDC和dispatch_once来实现之外，我们还可以使用线程安全的<strong>let</strong>实现。</p>\n<pre><code>class DataReader: NSObject {\n    class var sharedReader:DataReader {\n        struct Static{\n            static let _instance = DataReader()\n        }\n        return Static._instance\n    }\n...\n}\n</code></pre><p>分析一下</p>\n<p>1.我们ShareReader可看成包装起来的静态属性；<br>2.而真正的静态属性我用struct来封起来不允许别的class修改；<br>3._instance是一个常量，它不能被修改成别的值。</p>\n<p>使用：</p>\n<pre><code>DataReader.sharedReader\n</code></pre><p>自从Xcode6 beta4加入了访问修饰词，我们现在可以简单的写成：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">let</span> _instance = <span class=\"type\">DataReader</span>()</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataReader</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">var</span> <span class=\"title\">sharedReader</span>:<span class=\"title\">DataReader</span> </span>&#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">return</span> _instance</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">```\t</span><br><span class=\"line\">### 结构体与枚举</span><br><span class=\"line\"><span class=\"type\">Swift</span>的结构体与枚举有很多强大特性你是在别的语言找不到的。</span><br><span class=\"line\"></span><br><span class=\"line\">它们支持写方法：</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">User</span></span>&#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// Struct properties</span></span><br><span class=\"line\">\t    <span class=\"keyword\">let</span> name:<span class=\"type\">String</span></span><br><span class=\"line\">\t    <span class=\"keyword\">let</span> <span class=\"type\">ID</span>:<span class=\"type\">Int</span></span><br><span class=\"line\">\t    <span class=\"comment\">// Method!!!</span></span><br><span class=\"line\">\t    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t        <span class=\"built_in\">println</span>(<span class=\"string\">\"I'm \"</span> + <span class=\"keyword\">self</span>.name + <span class=\"string\">\" my ID is: <span class=\"subst\">\\(<span class=\"keyword\">self</span>.ID)</span>\"</span>)</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> pamela = <span class=\"type\">User</span>(name: <span class=\"string\">\"Pamela\"</span>, <span class=\"type\">ID</span>: <span class=\"number\">123456</span>)</span><br><span class=\"line\">\tpamela.sayHello()</span><br><span class=\"line\">```\t</span><br><span class=\"line\">可以见到<span class=\"type\">Swift</span>对结构体有默认的initializer。而枚举的语法有很大不同是用了**<span class=\"keyword\">case</span>**:</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Fruit</span> </span>&#123; </span><br><span class=\"line\">\t  <span class=\"keyword\">case</span> orange</span><br><span class=\"line\">\t  <span class=\"keyword\">case</span> apple</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不再限制与整数：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Fruit</span>:<span class=\"title\">String</span> </span>&#123; </span><br><span class=\"line\">\t  <span class=\"keyword\">case</span> .orange = <span class=\"string\">\"Orange\"</span></span><br><span class=\"line\">\t  <span class=\"keyword\">case</span> .apple = <span class=\"string\">\"Apple\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">```\t</span><br><span class=\"line\">甚至可以给它定义更多行为：</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Fruit</span></span>&#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// Available Fruits</span></span><br><span class=\"line\">\t    <span class=\"keyword\">case</span> orange</span><br><span class=\"line\">\t    <span class=\"keyword\">case</span> apple</span><br><span class=\"line\">\t    <span class=\"comment\">// Nested type</span></span><br><span class=\"line\">\t    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Vitamin</span></span>&#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">var</span> name:<span class=\"type\">String</span></span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    <span class=\"comment\">// Compound property</span></span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> mainVitamin:<span class=\"type\">Vitamin</span> &#123;</span><br><span class=\"line\">\t\t    <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span>&#123;</span><br><span class=\"line\">\t\t\t    <span class=\"keyword\">case</span> .orange:</span><br><span class=\"line\">\t\t        <span class=\"keyword\">return</span> <span class=\"type\">Vitamin</span>(name: <span class=\"string\">\"C\"</span>)</span><br><span class=\"line\">\t\t    <span class=\"keyword\">case</span> .apple:</span><br><span class=\"line\">\t\t        <span class=\"keyword\">return</span> <span class=\"type\">Vitamin</span>(name: <span class=\"string\">\"B\"</span>)</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\t<span class=\"keyword\">let</span> <span class=\"type\">Apple</span> = <span class=\"type\">Fruit</span>.apple</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> <span class=\"type\">Vitamin</span> = <span class=\"type\">Apple</span>.mainVitamin</span><br></pre></td></tr></table></figure></p>\n<p>这段代码我们加了一个内嵌类型(Vitamin)和一个compound property(mainVitamin)，这样不同的枚举值出来的mainVitamin就不一样了，这功能真赞！</p>\n<h3 id=\"Blocks-VS-Closures\"><a href=\"#Blocks-VS-Closures\" class=\"headerlink\" title=\"Blocks VS Closures\"></a>Blocks VS Closures</h3><p>我非常喜欢blocks，一些简单的delegate我都爱用blocks来替代，它灵活、快速、安全。而在Swift里是用Closures来代替Blocks的。它再续了Blocks的优点，简化了语法，令我爱不惜手。<br>以下是官方用Closures实现reversed的例子：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\treversed = <span class=\"built_in\">sort</span>(names, &#123; (s1: <span class=\"type\">String</span>, s2: <span class=\"type\">String</span>) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> s1 &gt; s2</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">```\t</span><br><span class=\"line\">简化成：</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\treversed = <span class=\"built_in\">sort</span>(names, &gt;) </span><br><span class=\"line\">```\t</span><br><span class=\"line\">这里我就不详解<span class=\"type\">Closure</span>的语法了，我来说说<span class=\"type\">Closure</span>的**capture values**。在<span class=\"type\">Objective</span>-<span class=\"type\">C</span>我们需要给变量加**__block**才能在block里面修改该外部变量。而用<span class=\"type\">Closure</span>，这不需要，我们能在<span class=\"type\">Closures</span>里访问和修改外部作用域的变量。另外，如果<span class=\"type\">Closure</span>里引用的实例包含或使用了<span class=\"type\">Closure</span>本身，这就会引起**循环引用**:</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">var</span> age:<span class=\"type\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">\t    <span class=\"meta\">@lazy</span> <span class=\"keyword\">var</span> agePotion: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Void</span> = &#123;</span><br><span class=\"line\">        (agex:<span class=\"type\">Int</span>)-&gt;<span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">\t            <span class=\"keyword\">self</span>.age += agex</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">modifyAge</span><span class=\"params\">(agex:Int, modifier:<span class=\"params\">(Int)</span></span></span>-&gt;<span class=\"type\">Void</span>)&#123;</span><br><span class=\"line\">\t        modifier(agex)</span><br><span class=\"line\">\t    &#125;   </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> <span class=\"type\">Mark</span>:<span class=\"type\">Person</span>? = <span class=\"type\">Person</span>()</span><br><span class=\"line\">\t<span class=\"type\">Mark</span>!.modifyAge(<span class=\"number\">50</span>, <span class=\"type\">Mark</span>!.agePotion)</span><br><span class=\"line\">\t<span class=\"type\">Mark</span> = <span class=\"literal\">nil</span> <span class=\"comment\">// Memory Leak</span></span><br><span class=\"line\">```\t</span><br><span class=\"line\">看到agePotion里用了<span class=\"keyword\">self</span>，**循环引用**就发生了，要避免这问题，我们可以用**<span class=\"type\">Capture</span> <span class=\"type\">List</span>**，这会时分配进<span class=\"type\">Closure</span>的实例是<span class=\"keyword\">weak</span>或者<span class=\"keyword\">unowned</span>的，写法也很简单，只需在<span class=\"type\">Closure</span>的定义前加上**[unownded <span class=\"keyword\">self</span>]**，就可以得到一个<span class=\"keyword\">unowned</span>或者<span class=\"keyword\">weak</span>的<span class=\"keyword\">self</span>了。</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"meta\">@lazy</span> <span class=\"keyword\">var</span> agePotion: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Void</span> = &#123;</span><br><span class=\"line\">\t     [<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>](agex:<span class=\"type\">Int</span>)-&gt;<span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">\t         <span class=\"keyword\">self</span>.age += agex</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">```\t</span><br><span class=\"line\">### <span class=\"type\">Unowned</span> &amp; <span class=\"type\">Weak</span> <span class=\"type\">Reference</span></span><br><span class=\"line\">我们知道**<span class=\"keyword\">weak</span> <span class=\"type\">Reference</span>**在<span class=\"type\">Objective</span>-<span class=\"type\">C</span>的使用，在<span class=\"type\">Swift</span>上也是一样的。那么**<span class=\"keyword\">unowned</span> reference**又是什么呢？我就举个例子来解析吧。</span><br><span class=\"line\"></span><br><span class=\"line\">我来描述一下一个人与他的银行账号的关系：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>.一个人可以有一个银行账号(<span class=\"keyword\">optional</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>.一个银行账号必须有拥有者(<span class=\"keyword\">required</span>)</span><br><span class=\"line\">```swift</span><br><span class=\"line\">\t<span class=\"comment\">//We can describe this relation with code: </span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">let</span> name:<span class=\"type\">String</span></span><br><span class=\"line\">\t    <span class=\"keyword\">let</span> account:<span class=\"type\">BankAccount</span>!</span><br><span class=\"line\">\t    <span class=\"keyword\">init</span>(name:<span class=\"type\">String</span>)&#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">\t        <span class=\"keyword\">self</span>.account = <span class=\"type\">BankAccount</span>(owner: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BankAccount</span></span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">let</span> owner:<span class=\"type\">Person</span></span><br><span class=\"line\">\t    <span class=\"keyword\">init</span>(owner:<span class=\"type\">Person</span>)&#123;</span><br><span class=\"line\">\t        <span class=\"keyword\">self</span>.owner = owner</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这就生成了一个引用循环。一种解决方案是对BankAccount.owner属性添加weak reference。你也可以使用unowned reference，但这个属性就必须要非空了。总结就是<strong>unowned</strong>就只是比<strong>weak</strong>多了一个非空限制而已，其他一样的。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>在写Swift的过程中，越来越发现一些有趣的特性，这令我更想多写Swift，期待正式版Xcode 6。</p>\n"},{"layout":"post","title":"raywenderlich.com Swift风格指南","date":"2014-09-08T07:28:49.000Z","comments":1,"_content":"\n因为该指南关注于网页上以及打印版的可读性，所以它可能与你阅读过的指南有所不同。为了保证那些在我们书中、教程里以及初学者工程里的代码美观并且一致，我们写下了这份风格指南，尽管书由许多不同作者共同创作而成。\n\n该指南的首要目标是让代码紧凑，可读性高且简洁。\n\n\n## 目录\n\n* [语言](#语言)\n* [间隔](#间隔)\n* [注释](#注释)\n* [命名](#命名)\n  * [类前缀](#类前缀)\n* [分号](#分号)\n* [类与结构体](#类与结构体)\n* [函数声明](#函数声明)\n* [闭包](#闭包)\n* [类型](#类型)\n  * [常量](#常量)\n  * [Optional](#Optional)\n  * [类型推导](#类型推导)\n  * [语法糖](#语法糖)\n* [控制流](#控制流)\n* [Self的使用](#Self的使用)\n* [笑脸](#笑脸)\n* [致谢](#致谢)\n\n## 语言\n\t\n使用美式英语拼写以确保和苹果公司的API一致\n\n**优选：**\n```swift\nvar color = \"red\"\n```\n\n**不建议使用：**\n```swift\nvar colour = \"red\"\n```\n\n## 间隔\n\n* 使用2个空格而不是Tab进行缩进，可以减少换行。确保在Xcode的配置项中使用此设置。\n* 方法的花括号以及其它花括号（`if`/`else`/`switch`/`while`等等）总是跟语句在同一行开始，新起一行结束。\n\n**优选：**\n\n```swift\nif user.isHappy {\n  //Do something\n} else {\n  //Do something else\n}\n```\n\n**不建议使用：**\n\n```swift\nif user.isHappy\n{\n    //Do something\n}\nelse {\n    //Do something else\n}\n```\n\n* 方法之间应该总是用一个空行进行分隔以提高视觉以及结构上的清晰度。方法中的空白用来分开功能块，但是如果一个方法中存在太多功能块时，通常意味着你需要将它重构为多个方法。\n\n## 注释\n\n* 在需要的时候使用注释说明一块代码**为什么**这么做。注释必须时刻跟进代码，不然删了得了。\n\n* 代码应该尽可能的自文档化，避免在代码中使用成块的注释。**例外：该规则不适用与用于生成文档的块注释。**\n\n## 命名\n\n使用驼峰法为类、方法、变量等取一个描述性强的名字。模块范围的类名和常量名以大写字母开头，而方法名和变量名应以小写字母开头。\n\n**优选：**\n\n```swift\nlet MaximumWidgetCount = 100\n\nclass WidgetContainer {\n  var widgetButton: UIButton\n  let widgetHeightPercentage = 0.85\n}\n```\n\n**不建议使用：**\n\n```swift\nlet MAX_WIDGET_COUNT = 100\n\nclass app_widgetContainer {\n  var wBut: UIButton\n  let wHeightPct = 0.85\n}\n```\n\n对于函数以及初始化方法，除非上下文含义非常清楚，推荐对所有的参数都加以命名。如果外部参数名称可以使得函数调用更易读，请加上它。\n\n```swift\nfunc dateFromString(dateString: NSString) -> NSDate\nfunc convertPointAt(#column: Int, #row: Int) -> CGPoint\nfunc timedAction(#delay: NSTimeInterval, perform action: SKAction) -> SKAction!\n\n// 会被这样调用\ndateFromString(\"2014-03-14\")\nconvertPointAt(column: 42, row: 13)\ntimedAction(delay: 1.0, perform: someOtherAction)\n```\n\n对于方法，遵循苹果公司的命名规范，在方法名中提及第一个参数：\n\n```swift\nclass Guideline {\n  func combineWithString(incoming: String, options: Dictionary?) { ... }\n  func upvoteBy(amount: Int) { ... }\n}\n```\n\n在所有提及到函数的内容中（包括教程，书以及评论），请从调用者的视角进行考虑，将所有的必要参数名都包含进来：\n\n```\ndateFromString()函数真是太棒了。\n在你的init()方法中调用convertPointAt(column:, row:)。\ntimedAction(delay:, perform:)的返回值可能为nil。\nGuideline对象只有两个方法：combineWithString(options:)和upvoteBy()。\n你不应该直接调用数据源方法tableView(cellForRowAtIndexPath:)。\n```\n\n### 类前缀\n\nSwift中的类型会被自动加入包含它们的模块的命名空间。所以减少命名冲突的前缀已经不必要了。如果同模块的两个名称冲突了，可以在名称前加上模块名消除歧义：\n\n```swift\nimport MyModule\n\nvar myClass = MyModule.MyClass()\n```\n\n**不应该**给自己创建的Swift类型加前缀。\n\n如果需要把Swift类型暴露给Objective-C使用，你可以添加一个合适的前缀（前缀的命名请参考[Objective-C风格指南][objc-style-guide]）:\n\n```swift\n@objc (RWTChicken) class Chicken {\n   ...\n}\n```\n\n## 分号\n\nSwift不要求每条语句后加分号。只有在你想把多条语句写到一行时才需要加上分号。\n\n请不要在一行中写上用分号隔开的多条语句。\n\n这条规则的唯一例外就是`for-conditional-increment`结构，该结构中分号是必需的。不过请尽量用`for-in`结构代替它们。\n\n**优选：**\n```swift\nvar swift = \"not a scripting language\"\n```\n\n**不建议使用：**\n```swift\nvar swift = \"not a scripting language\";\n```\n\n**请注意**：Swift与JavaScript不同, 在后者中省略分号[通常是不安全的](http://stackoverflow.com/questions/444080/do-you-recommend-using-semicolons-after-every-statement-in-javascript)。\n\n## 类与结构体\n\n下面是一个风格良好的类定义代码例子，请参考：\n\n```swift\nclass Circle: Shape {\n  var x: Int, y: Int\n  var radius: Double\n  var diameter: Double {\n    get {\n      return radius * 2\n    }\n    set {\n      radius = newValue / 2\n    }\n  }\n\n  init(x: Int, y: Int, radius: Double) {\n    self.x = x\n    self.y = y\n    self.radius = radius\n  }\n\n  convenience init(x: Int, y: Int, diameter: Double) {\n    self.init(x: x, y: y, radius: diameter / 2)\n  }\n\n  func describe() -> String {\n    return \"I am a circle at (\\(x),\\(y)) with an area of \\(computeArea())\"\n  }\n\n  func computeArea() -> Double {\n    return M_PI * radius * radius\n  }  \n}\n```\n上面的例子阐述了如下的风格准则：\n\n+ 给属性、变量、常量、参数及其它语句指定类型时，在冒号的后面加上空格而不是前面，比如：`x: Int`跟`Circle: Shape`。\n+ 对getter跟setter定义以及属性观察器进行缩进。\n+ 如果多个变量、结构有着同样的目的或者上下文，在同一行上进行定义。\n\n## Self的使用\n\n在Swift中访问对象属性或调用方法时不需要使用`self`，请避免使用它。\n\n使用`self`的唯一理由是在初始化一个类或结构体时区分属性名和参数名：\n\n```swift\nclass BoardLocation {\n  let row: Int, column: Int\n\n  init(row: Int,column: Int) {\n    self.row = row\n    self.column = column\n  }\n}\n```\n\n## 函数声明\n\n保持函数声明短小精悍，保持在一行内，花括号在同一行内开始：\n\n```swift\nfunc reticulateSplines(spline: [Double]) -> Bool {\n  // reticulate code goes here\n}\n```\n\n对于有着长签名的函数，请在适当的位置进行断行且对后续行缩进一级：\n\n```swift\nfunc reticulateSplines(spline: [Double], adjustmentFactor: Double,\n    translateConstant: Int, comment: String) -> Bool {\n  // reticulate code goes here\n}\n```\n\n## 闭包\n\n尽可能地使用尾闭包语法。在所有的情况下给闭包参数一个描述性强的名称：\n\n```swift\nreturn SKAction.customActionWithDuration(effect.duration) { node, elapsedTime in \n  // more code goes here\n}\n```\n\n对于上下文清晰的单表达式闭包，使用隐式的返回值：\n\n```swift\nattendeeList.sort { a, b in\n  a > b\n}\n```\n\n## 类型\n\n如果可能，使用Swift的原生类型。Swift提供了对Objective-C的桥接，如果需要，仍然可以使用全部的Objective-C方法：\n\n**优选：**\n```swift\nlet width = 120.0                                           //Double\nlet widthString = width.bridgeToObjectiveC().stringValue    //String\n```\n\n**不建议使用：**\n```swift\nlet width: NSNumber = 120.0                                 //NSNumber\nlet widthString: NSString = width.stringValue               //NSString\n```\n\n在Sprite Kit的代码中，如果`CGFloat`可以避免过多的转换从而使得代码简洁，那么请使用它。\n\n### 常量\n\n常量通过`let`关键字定义，而变量使用`var`关键字定义。任何值如果**是**一个不变量，那么请使用`let`关键字恰如其分地定义它。最后你会发现自己喜欢使用`let`远多于`far`。\n\n**Tip：**有一个方法可以帮你满足该项规则，将所有值都定义成常量，然后编译器提示的时候将其改为变量。\n\n### Optional\n\n在nil值可能出现的情况下，将变量跟函数返回值的类型通过`?`定义成Optional。\n\n只有在确定实例变量会在初始化之后才被使用的情况下，通过`!`将其定义为隐式解包类型（Implicitly Unwrapped Types），比如说会在`viewDidLoad`中被创建的子视图。\n\n在访问一个Optional值时，如果该值只被访问一次，或者之后需要连续访问多个Optional值，请使用链式Optional语法：\n\n```swift\nmyOptional?.anotherOne?.optionalView?.setNeedsDisplay()\n```\n\n对于需要将Optional值解开一次，然后进行多个操作的情况，使用Optional绑定更为方便：\n\n```swift\nif let view = self.optionalView {\n  // do many things with view\n}\n```\n\n### 类型推导\n\nSwift的编译器可以推导出变量和常量的类型。可以显式地提供类型别名（冒号后面声明的类型），不过大多数情况下这都是不必要的。\n\n保持代码紧凑，然后让编译器推断变量跟常量的类型。\n\n**优选：**\n```swift\nlet message = \"Click the button\"\nvar currentBounds = computeViewBounds()\n```\n\n**不建议使用：**\n```swift\nlet message: String = \"Click the button\"\nvar currentBounds: CGRect = computeViewBounds()\n```\n\n**注意**：遵循这条准则意味着使用描述性强的名称比之前更为重要了。\n\n### 语法糖\n\nPrefer the shortcut versions of type declarations over the full generics syntax.\n\n使用简写的类型声明，而不是它的全泛型版本。\n\n**优选：**\n```swift\nvar deviceModels: [String]\nvar employees: [Int: String]\nvar faxNumber: Int?\n```\n\n**不建议使用：**\n```swift\nvar deviceModels: Array<String>\nvar employees: Dictionary<Int, String>\nvar faxNumber: Optional<Int>\n```\n\n## 控制流\n\n对于`for`循环，优选`for-in`风格而不是`for-condition-increment`风格：\n\n**优选：**\n```swift\nfor _ in 0..<3 {\n  println(\"Hello three times\")\n}\n\nfor person in attendeeList {\n  // do something\n}\n```\n\n**不建议使用：**\n```swift\nfor var i = 0; i < 3; i++ {\n  println(\"Hello three times\")\n}\n\nfor var i = 0; i < attendeeList.count; i++ {\n  let person = attendeeList[i]\n  // do something\n}\n```\n\n## 笑脸\n\n笑脸对于raywenderlich.com来说是一个格外重要的风格特征。使用正确的笑脸可以表示出对某个主题的无穷尽的高兴以及兴奋程度。选用了`]`是因为它在ASCII艺术可以表示得最大的笑脸。而闭圆括号`)`因为给人一种“**呵呵**”的感觉而不建议使用。\n\n**优选：**\n```\n:]\n```\n\n**不建议使用：**\n```\n:)\n``` \n\n## 致谢\n\n该风格指南是由下面这些格外有范儿的raywenderlich.com团队成员齐心协力一同打造：\n\n* [Soheil Moayedi Azarpour](https://github.com/moayes)\n* [Scott Berrevoets](https://github.com/Scott90)\n* [Eric Cerney](https://github.com/ecerney)\n* [Sam Davies](https://github.com/sammyd)\n* [Evan Dekhayser](https://github.com/edekhayser)\n* [Jean-Pierre Distler](https://github.com/pdistler)\n* [Colin Eberhardt](https://github.com/ColinEberhardt)\n* [Greg Heo](https://github.com/gregheo)\n* [Matthijs Hollemans](https://github.com/hollance)\n* [Erik Kerber](https://github.com/eskerber)\n* [Christopher LaPollo](https://github.com/elephantronic)\n* [Andy Pereira](https://github.com/macandyp)\n* [Ryan Nystrom](https://github.com/rnystrom)\n* [Cesare Rocchi](https://github.com/funkyboy)\n* [Ellen Shapiro](https://github.com/designatednerd)\n* [Marin Todorov](https://github.com/icanzilb)\n* [Chris Wagner](https://github.com/cwagdev)\n* [Ray Wenderlich](https://github.com/rwenderlich)\n* [Jack Wu](https://github.com/jackwu95)\n\n向[Nicholas Waynik](https://github.com/ndubbs)以及[Objective-C风格指南](https://github.com/raywenderlich/objective-c-style-guide)团队脱帽致礼！\n\n我们也从苹果公司的有关Swift的参考材料中获取了灵感：\n\n* [The Swift Programming Language](https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/index.html)\n* [Using Swift with Cocoa and Objective-C](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html)\n* [Swift Standard Library Reference](https://developer.apple.com/library/prerelease/ios/documentation/General/Reference/SwiftStandardLibraryReference/index.html)\n\n\n[objc-style-guide]: https://github.com/raywenderlich/objective-c-style-guide\n\n","source":"_posts/2014-09-08-raywenderlich-dot-com-swiftfeng-ge-zhi-nan.markdown","raw":"---\nlayout: post\ntitle: \"raywenderlich.com Swift风格指南\"\ndate: 2014-09-08 15:28:49 +0800\ncomments: true\ncategories: \n---\n\n因为该指南关注于网页上以及打印版的可读性，所以它可能与你阅读过的指南有所不同。为了保证那些在我们书中、教程里以及初学者工程里的代码美观并且一致，我们写下了这份风格指南，尽管书由许多不同作者共同创作而成。\n\n该指南的首要目标是让代码紧凑，可读性高且简洁。\n\n\n## 目录\n\n* [语言](#语言)\n* [间隔](#间隔)\n* [注释](#注释)\n* [命名](#命名)\n  * [类前缀](#类前缀)\n* [分号](#分号)\n* [类与结构体](#类与结构体)\n* [函数声明](#函数声明)\n* [闭包](#闭包)\n* [类型](#类型)\n  * [常量](#常量)\n  * [Optional](#Optional)\n  * [类型推导](#类型推导)\n  * [语法糖](#语法糖)\n* [控制流](#控制流)\n* [Self的使用](#Self的使用)\n* [笑脸](#笑脸)\n* [致谢](#致谢)\n\n## 语言\n\t\n使用美式英语拼写以确保和苹果公司的API一致\n\n**优选：**\n```swift\nvar color = \"red\"\n```\n\n**不建议使用：**\n```swift\nvar colour = \"red\"\n```\n\n## 间隔\n\n* 使用2个空格而不是Tab进行缩进，可以减少换行。确保在Xcode的配置项中使用此设置。\n* 方法的花括号以及其它花括号（`if`/`else`/`switch`/`while`等等）总是跟语句在同一行开始，新起一行结束。\n\n**优选：**\n\n```swift\nif user.isHappy {\n  //Do something\n} else {\n  //Do something else\n}\n```\n\n**不建议使用：**\n\n```swift\nif user.isHappy\n{\n    //Do something\n}\nelse {\n    //Do something else\n}\n```\n\n* 方法之间应该总是用一个空行进行分隔以提高视觉以及结构上的清晰度。方法中的空白用来分开功能块，但是如果一个方法中存在太多功能块时，通常意味着你需要将它重构为多个方法。\n\n## 注释\n\n* 在需要的时候使用注释说明一块代码**为什么**这么做。注释必须时刻跟进代码，不然删了得了。\n\n* 代码应该尽可能的自文档化，避免在代码中使用成块的注释。**例外：该规则不适用与用于生成文档的块注释。**\n\n## 命名\n\n使用驼峰法为类、方法、变量等取一个描述性强的名字。模块范围的类名和常量名以大写字母开头，而方法名和变量名应以小写字母开头。\n\n**优选：**\n\n```swift\nlet MaximumWidgetCount = 100\n\nclass WidgetContainer {\n  var widgetButton: UIButton\n  let widgetHeightPercentage = 0.85\n}\n```\n\n**不建议使用：**\n\n```swift\nlet MAX_WIDGET_COUNT = 100\n\nclass app_widgetContainer {\n  var wBut: UIButton\n  let wHeightPct = 0.85\n}\n```\n\n对于函数以及初始化方法，除非上下文含义非常清楚，推荐对所有的参数都加以命名。如果外部参数名称可以使得函数调用更易读，请加上它。\n\n```swift\nfunc dateFromString(dateString: NSString) -> NSDate\nfunc convertPointAt(#column: Int, #row: Int) -> CGPoint\nfunc timedAction(#delay: NSTimeInterval, perform action: SKAction) -> SKAction!\n\n// 会被这样调用\ndateFromString(\"2014-03-14\")\nconvertPointAt(column: 42, row: 13)\ntimedAction(delay: 1.0, perform: someOtherAction)\n```\n\n对于方法，遵循苹果公司的命名规范，在方法名中提及第一个参数：\n\n```swift\nclass Guideline {\n  func combineWithString(incoming: String, options: Dictionary?) { ... }\n  func upvoteBy(amount: Int) { ... }\n}\n```\n\n在所有提及到函数的内容中（包括教程，书以及评论），请从调用者的视角进行考虑，将所有的必要参数名都包含进来：\n\n```\ndateFromString()函数真是太棒了。\n在你的init()方法中调用convertPointAt(column:, row:)。\ntimedAction(delay:, perform:)的返回值可能为nil。\nGuideline对象只有两个方法：combineWithString(options:)和upvoteBy()。\n你不应该直接调用数据源方法tableView(cellForRowAtIndexPath:)。\n```\n\n### 类前缀\n\nSwift中的类型会被自动加入包含它们的模块的命名空间。所以减少命名冲突的前缀已经不必要了。如果同模块的两个名称冲突了，可以在名称前加上模块名消除歧义：\n\n```swift\nimport MyModule\n\nvar myClass = MyModule.MyClass()\n```\n\n**不应该**给自己创建的Swift类型加前缀。\n\n如果需要把Swift类型暴露给Objective-C使用，你可以添加一个合适的前缀（前缀的命名请参考[Objective-C风格指南][objc-style-guide]）:\n\n```swift\n@objc (RWTChicken) class Chicken {\n   ...\n}\n```\n\n## 分号\n\nSwift不要求每条语句后加分号。只有在你想把多条语句写到一行时才需要加上分号。\n\n请不要在一行中写上用分号隔开的多条语句。\n\n这条规则的唯一例外就是`for-conditional-increment`结构，该结构中分号是必需的。不过请尽量用`for-in`结构代替它们。\n\n**优选：**\n```swift\nvar swift = \"not a scripting language\"\n```\n\n**不建议使用：**\n```swift\nvar swift = \"not a scripting language\";\n```\n\n**请注意**：Swift与JavaScript不同, 在后者中省略分号[通常是不安全的](http://stackoverflow.com/questions/444080/do-you-recommend-using-semicolons-after-every-statement-in-javascript)。\n\n## 类与结构体\n\n下面是一个风格良好的类定义代码例子，请参考：\n\n```swift\nclass Circle: Shape {\n  var x: Int, y: Int\n  var radius: Double\n  var diameter: Double {\n    get {\n      return radius * 2\n    }\n    set {\n      radius = newValue / 2\n    }\n  }\n\n  init(x: Int, y: Int, radius: Double) {\n    self.x = x\n    self.y = y\n    self.radius = radius\n  }\n\n  convenience init(x: Int, y: Int, diameter: Double) {\n    self.init(x: x, y: y, radius: diameter / 2)\n  }\n\n  func describe() -> String {\n    return \"I am a circle at (\\(x),\\(y)) with an area of \\(computeArea())\"\n  }\n\n  func computeArea() -> Double {\n    return M_PI * radius * radius\n  }  \n}\n```\n上面的例子阐述了如下的风格准则：\n\n+ 给属性、变量、常量、参数及其它语句指定类型时，在冒号的后面加上空格而不是前面，比如：`x: Int`跟`Circle: Shape`。\n+ 对getter跟setter定义以及属性观察器进行缩进。\n+ 如果多个变量、结构有着同样的目的或者上下文，在同一行上进行定义。\n\n## Self的使用\n\n在Swift中访问对象属性或调用方法时不需要使用`self`，请避免使用它。\n\n使用`self`的唯一理由是在初始化一个类或结构体时区分属性名和参数名：\n\n```swift\nclass BoardLocation {\n  let row: Int, column: Int\n\n  init(row: Int,column: Int) {\n    self.row = row\n    self.column = column\n  }\n}\n```\n\n## 函数声明\n\n保持函数声明短小精悍，保持在一行内，花括号在同一行内开始：\n\n```swift\nfunc reticulateSplines(spline: [Double]) -> Bool {\n  // reticulate code goes here\n}\n```\n\n对于有着长签名的函数，请在适当的位置进行断行且对后续行缩进一级：\n\n```swift\nfunc reticulateSplines(spline: [Double], adjustmentFactor: Double,\n    translateConstant: Int, comment: String) -> Bool {\n  // reticulate code goes here\n}\n```\n\n## 闭包\n\n尽可能地使用尾闭包语法。在所有的情况下给闭包参数一个描述性强的名称：\n\n```swift\nreturn SKAction.customActionWithDuration(effect.duration) { node, elapsedTime in \n  // more code goes here\n}\n```\n\n对于上下文清晰的单表达式闭包，使用隐式的返回值：\n\n```swift\nattendeeList.sort { a, b in\n  a > b\n}\n```\n\n## 类型\n\n如果可能，使用Swift的原生类型。Swift提供了对Objective-C的桥接，如果需要，仍然可以使用全部的Objective-C方法：\n\n**优选：**\n```swift\nlet width = 120.0                                           //Double\nlet widthString = width.bridgeToObjectiveC().stringValue    //String\n```\n\n**不建议使用：**\n```swift\nlet width: NSNumber = 120.0                                 //NSNumber\nlet widthString: NSString = width.stringValue               //NSString\n```\n\n在Sprite Kit的代码中，如果`CGFloat`可以避免过多的转换从而使得代码简洁，那么请使用它。\n\n### 常量\n\n常量通过`let`关键字定义，而变量使用`var`关键字定义。任何值如果**是**一个不变量，那么请使用`let`关键字恰如其分地定义它。最后你会发现自己喜欢使用`let`远多于`far`。\n\n**Tip：**有一个方法可以帮你满足该项规则，将所有值都定义成常量，然后编译器提示的时候将其改为变量。\n\n### Optional\n\n在nil值可能出现的情况下，将变量跟函数返回值的类型通过`?`定义成Optional。\n\n只有在确定实例变量会在初始化之后才被使用的情况下，通过`!`将其定义为隐式解包类型（Implicitly Unwrapped Types），比如说会在`viewDidLoad`中被创建的子视图。\n\n在访问一个Optional值时，如果该值只被访问一次，或者之后需要连续访问多个Optional值，请使用链式Optional语法：\n\n```swift\nmyOptional?.anotherOne?.optionalView?.setNeedsDisplay()\n```\n\n对于需要将Optional值解开一次，然后进行多个操作的情况，使用Optional绑定更为方便：\n\n```swift\nif let view = self.optionalView {\n  // do many things with view\n}\n```\n\n### 类型推导\n\nSwift的编译器可以推导出变量和常量的类型。可以显式地提供类型别名（冒号后面声明的类型），不过大多数情况下这都是不必要的。\n\n保持代码紧凑，然后让编译器推断变量跟常量的类型。\n\n**优选：**\n```swift\nlet message = \"Click the button\"\nvar currentBounds = computeViewBounds()\n```\n\n**不建议使用：**\n```swift\nlet message: String = \"Click the button\"\nvar currentBounds: CGRect = computeViewBounds()\n```\n\n**注意**：遵循这条准则意味着使用描述性强的名称比之前更为重要了。\n\n### 语法糖\n\nPrefer the shortcut versions of type declarations over the full generics syntax.\n\n使用简写的类型声明，而不是它的全泛型版本。\n\n**优选：**\n```swift\nvar deviceModels: [String]\nvar employees: [Int: String]\nvar faxNumber: Int?\n```\n\n**不建议使用：**\n```swift\nvar deviceModels: Array<String>\nvar employees: Dictionary<Int, String>\nvar faxNumber: Optional<Int>\n```\n\n## 控制流\n\n对于`for`循环，优选`for-in`风格而不是`for-condition-increment`风格：\n\n**优选：**\n```swift\nfor _ in 0..<3 {\n  println(\"Hello three times\")\n}\n\nfor person in attendeeList {\n  // do something\n}\n```\n\n**不建议使用：**\n```swift\nfor var i = 0; i < 3; i++ {\n  println(\"Hello three times\")\n}\n\nfor var i = 0; i < attendeeList.count; i++ {\n  let person = attendeeList[i]\n  // do something\n}\n```\n\n## 笑脸\n\n笑脸对于raywenderlich.com来说是一个格外重要的风格特征。使用正确的笑脸可以表示出对某个主题的无穷尽的高兴以及兴奋程度。选用了`]`是因为它在ASCII艺术可以表示得最大的笑脸。而闭圆括号`)`因为给人一种“**呵呵**”的感觉而不建议使用。\n\n**优选：**\n```\n:]\n```\n\n**不建议使用：**\n```\n:)\n``` \n\n## 致谢\n\n该风格指南是由下面这些格外有范儿的raywenderlich.com团队成员齐心协力一同打造：\n\n* [Soheil Moayedi Azarpour](https://github.com/moayes)\n* [Scott Berrevoets](https://github.com/Scott90)\n* [Eric Cerney](https://github.com/ecerney)\n* [Sam Davies](https://github.com/sammyd)\n* [Evan Dekhayser](https://github.com/edekhayser)\n* [Jean-Pierre Distler](https://github.com/pdistler)\n* [Colin Eberhardt](https://github.com/ColinEberhardt)\n* [Greg Heo](https://github.com/gregheo)\n* [Matthijs Hollemans](https://github.com/hollance)\n* [Erik Kerber](https://github.com/eskerber)\n* [Christopher LaPollo](https://github.com/elephantronic)\n* [Andy Pereira](https://github.com/macandyp)\n* [Ryan Nystrom](https://github.com/rnystrom)\n* [Cesare Rocchi](https://github.com/funkyboy)\n* [Ellen Shapiro](https://github.com/designatednerd)\n* [Marin Todorov](https://github.com/icanzilb)\n* [Chris Wagner](https://github.com/cwagdev)\n* [Ray Wenderlich](https://github.com/rwenderlich)\n* [Jack Wu](https://github.com/jackwu95)\n\n向[Nicholas Waynik](https://github.com/ndubbs)以及[Objective-C风格指南](https://github.com/raywenderlich/objective-c-style-guide)团队脱帽致礼！\n\n我们也从苹果公司的有关Swift的参考材料中获取了灵感：\n\n* [The Swift Programming Language](https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/index.html)\n* [Using Swift with Cocoa and Objective-C](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html)\n* [Swift Standard Library Reference](https://developer.apple.com/library/prerelease/ios/documentation/General/Reference/SwiftStandardLibraryReference/index.html)\n\n\n[objc-style-guide]: https://github.com/raywenderlich/objective-c-style-guide\n\n","slug":"2014-09-08-raywenderlich-dot-com-swiftfeng-ge-zhi-nan","published":1,"updated":"2014-09-08T07:43:52.000Z","photos":[],"link":"","_id":"cimohsgpq0005sqphgltjyt2o","content":"<p>因为该指南关注于网页上以及打印版的可读性，所以它可能与你阅读过的指南有所不同。为了保证那些在我们书中、教程里以及初学者工程里的代码美观并且一致，我们写下了这份风格指南，尽管书由许多不同作者共同创作而成。</p>\n<p>该指南的首要目标是让代码紧凑，可读性高且简洁。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li><a href=\"#语言\">语言</a></li>\n<li><a href=\"#间隔\">间隔</a></li>\n<li><a href=\"#注释\">注释</a></li>\n<li><a href=\"#命名\">命名</a><ul>\n<li><a href=\"#类前缀\">类前缀</a></li>\n</ul>\n</li>\n<li><a href=\"#分号\">分号</a></li>\n<li><a href=\"#类与结构体\">类与结构体</a></li>\n<li><a href=\"#函数声明\">函数声明</a></li>\n<li><a href=\"#闭包\">闭包</a></li>\n<li><a href=\"#类型\">类型</a><ul>\n<li><a href=\"#常量\">常量</a></li>\n<li><a href=\"#Optional\">Optional</a></li>\n<li><a href=\"#类型推导\">类型推导</a></li>\n<li><a href=\"#语法糖\">语法糖</a></li>\n</ul>\n</li>\n<li><a href=\"#控制流\">控制流</a></li>\n<li><a href=\"#Self的使用\">Self的使用</a></li>\n<li><a href=\"#笑脸\">笑脸</a></li>\n<li><a href=\"#致谢\">致谢</a></li>\n</ul>\n<h2 id=\"语言\"><a href=\"#语言\" class=\"headerlink\" title=\"语言\"></a>语言</h2><p>使用美式英语拼写以确保和苹果公司的API一致</p>\n<p><strong>优选：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> color = <span class=\"string\">\"red\"</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>不建议使用：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> colour = <span class=\"string\">\"red\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"间隔\"><a href=\"#间隔\" class=\"headerlink\" title=\"间隔\"></a>间隔</h2><ul>\n<li>使用2个空格而不是Tab进行缩进，可以减少换行。确保在Xcode的配置项中使用此设置。</li>\n<li>方法的花括号以及其它花括号（<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code>等等）总是跟语句在同一行开始，新起一行结束。</li>\n</ul>\n<p><strong>优选：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> user.isHappy &#123;</span><br><span class=\"line\">  <span class=\"comment\">//Do something</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//Do something else</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不建议使用：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> user.isHappy</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//Do something else</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法之间应该总是用一个空行进行分隔以提高视觉以及结构上的清晰度。方法中的空白用来分开功能块，但是如果一个方法中存在太多功能块时，通常意味着你需要将它重构为多个方法。</li>\n</ul>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><ul>\n<li><p>在需要的时候使用注释说明一块代码<strong>为什么</strong>这么做。注释必须时刻跟进代码，不然删了得了。</p>\n</li>\n<li><p>代码应该尽可能的自文档化，避免在代码中使用成块的注释。<strong>例外：该规则不适用与用于生成文档的块注释。</strong></p>\n</li>\n</ul>\n<h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h2><p>使用驼峰法为类、方法、变量等取一个描述性强的名字。模块范围的类名和常量名以大写字母开头，而方法名和变量名应以小写字母开头。</p>\n<p><strong>优选：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">MaximumWidgetCount</span> = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WidgetContainer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> widgetButton: <span class=\"type\">UIButton</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> widgetHeightPercentage = <span class=\"number\">0.85</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不建议使用：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">MAX_WIDGET_COUNT</span> = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">app_widgetContainer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> wBut: <span class=\"type\">UIButton</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> wHeightPct = <span class=\"number\">0.85</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于函数以及初始化方法，除非上下文含义非常清楚，推荐对所有的参数都加以命名。如果外部参数名称可以使得函数调用更易读，请加上它。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dateFromString</span><span class=\"params\">(dateString: NSString)</span></span> -&gt; <span class=\"type\">NSDate</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">convertPointAt</span><span class=\"params\">(#column: Int, #row: Int)</span></span> -&gt; <span class=\"type\">CGPoint</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">timedAction</span><span class=\"params\">(#delay: NSTimeInterval, perform action: SKAction)</span></span> -&gt; <span class=\"type\">SKAction</span>!</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 会被这样调用</span></span><br><span class=\"line\">dateFromString(<span class=\"string\">\"2014-03-14\"</span>)</span><br><span class=\"line\">convertPointAt(column: <span class=\"number\">42</span>, row: <span class=\"number\">13</span>)</span><br><span class=\"line\">timedAction(delay: <span class=\"number\">1.0</span>, perform: someOtherAction)</span><br></pre></td></tr></table></figure>\n<p>对于方法，遵循苹果公司的命名规范，在方法名中提及第一个参数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Guideline</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">combineWithString</span><span class=\"params\">(incoming: String, options: Dictionary?)</span></span> &#123; ... &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">upvoteBy</span><span class=\"params\">(amount: Int)</span></span> &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在所有提及到函数的内容中（包括教程，书以及评论），请从调用者的视角进行考虑，将所有的必要参数名都包含进来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dateFromString()函数真是太棒了。</span><br><span class=\"line\">在你的init()方法中调用convertPointAt(column:, row:)。</span><br><span class=\"line\">timedAction(delay:, perform:)的返回值可能为nil。</span><br><span class=\"line\">Guideline对象只有两个方法：combineWithString(options:)和upvoteBy()。</span><br><span class=\"line\">你不应该直接调用数据源方法tableView(cellForRowAtIndexPath:)。</span><br></pre></td></tr></table></figure>\n<h3 id=\"类前缀\"><a href=\"#类前缀\" class=\"headerlink\" title=\"类前缀\"></a>类前缀</h3><p>Swift中的类型会被自动加入包含它们的模块的命名空间。所以减少命名冲突的前缀已经不必要了。如果同模块的两个名称冲突了，可以在名称前加上模块名消除歧义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> MyModule</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myClass = <span class=\"type\">MyModule</span>.<span class=\"type\">MyClass</span>()</span><br></pre></td></tr></table></figure>\n<p><strong>不应该</strong>给自己创建的Swift类型加前缀。</p>\n<p>如果需要把Swift类型暴露给Objective-C使用，你可以添加一个合适的前缀（前缀的命名请参考<a href=\"https://github.com/raywenderlich/objective-c-style-guide\" target=\"_blank\" rel=\"external\">Objective-C风格指南</a>）:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@objc</span> (<span class=\"type\">RWTChicken</span>) <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chicken</span> </span>&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分号\"><a href=\"#分号\" class=\"headerlink\" title=\"分号\"></a>分号</h2><p>Swift不要求每条语句后加分号。只有在你想把多条语句写到一行时才需要加上分号。</p>\n<p>请不要在一行中写上用分号隔开的多条语句。</p>\n<p>这条规则的唯一例外就是<code>for-conditional-increment</code>结构，该结构中分号是必需的。不过请尽量用<code>for-in</code>结构代替它们。</p>\n<p><strong>优选：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> swift = <span class=\"string\">\"not a scripting language\"</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>不建议使用：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> swift = <span class=\"string\">\"not a scripting language\"</span>;</span><br></pre></td></tr></table></figure></p>\n<p><strong>请注意</strong>：Swift与JavaScript不同, 在后者中省略分号<a href=\"http://stackoverflow.com/questions/444080/do-you-recommend-using-semicolons-after-every-statement-in-javascript\" target=\"_blank\" rel=\"external\">通常是不安全的</a>。</p>\n<h2 id=\"类与结构体\"><a href=\"#类与结构体\" class=\"headerlink\" title=\"类与结构体\"></a>类与结构体</h2><p>下面是一个风格良好的类定义代码例子，请参考：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span>: <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> radius: <span class=\"type\">Double</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> diameter: <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> radius * <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">      radius = newValue / <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">init</span>(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>, radius: <span class=\"type\">Double</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.x = x</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.y = y</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.radius = radius</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>, diameter: <span class=\"type\">Double</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(x: x, y: y, radius: diameter / <span class=\"number\">2</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"I am a circle at (<span class=\"subst\">\\(x)</span>,<span class=\"subst\">\\(y)</span>) with an area of <span class=\"subst\">\\(computeArea()</span>)\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">computeArea</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">M_PI</span> * radius * radius</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子阐述了如下的风格准则：</p>\n<ul>\n<li>给属性、变量、常量、参数及其它语句指定类型时，在冒号的后面加上空格而不是前面，比如：<code>x: Int</code>跟<code>Circle: Shape</code>。</li>\n<li>对getter跟setter定义以及属性观察器进行缩进。</li>\n<li>如果多个变量、结构有着同样的目的或者上下文，在同一行上进行定义。</li>\n</ul>\n<h2 id=\"Self的使用\"><a href=\"#Self的使用\" class=\"headerlink\" title=\"Self的使用\"></a>Self的使用</h2><p>在Swift中访问对象属性或调用方法时不需要使用<code>self</code>，请避免使用它。</p>\n<p>使用<code>self</code>的唯一理由是在初始化一个类或结构体时区分属性名和参数名：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoardLocation</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> row: <span class=\"type\">Int</span>, column: <span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">init</span>(row: <span class=\"type\">Int</span>,column: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.row = row</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.column = column</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h2><p>保持函数声明短小精悍，保持在一行内，花括号在同一行内开始：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reticulateSplines</span><span class=\"params\">(spline: [Double])</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// reticulate code goes here</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于有着长签名的函数，请在适当的位置进行断行且对后续行缩进一级：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reticulateSplines</span><span class=\"params\">(spline: [Double], adjustmentFactor: Double,</span><br><span class=\"line\">    translateConstant: Int, comment: String)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// reticulate code goes here</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>尽可能地使用尾闭包语法。在所有的情况下给闭包参数一个描述性强的名称：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">SKAction</span>.customActionWithDuration(effect.duration) &#123; node, elapsedTime <span class=\"keyword\">in</span> </span><br><span class=\"line\">  <span class=\"comment\">// more code goes here</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于上下文清晰的单表达式闭包，使用隐式的返回值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attendeeList.<span class=\"built_in\">sort</span> &#123; a, b <span class=\"keyword\">in</span></span><br><span class=\"line\">  a &gt; b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><p>如果可能，使用Swift的原生类型。Swift提供了对Objective-C的桥接，如果需要，仍然可以使用全部的Objective-C方法：</p>\n<p><strong>优选：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> width = <span class=\"number\">120.0</span>                                           <span class=\"comment\">//Double</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> widthString = width.<span class=\"built_in\">bridgeToObjectiveC</span>().stringValue    <span class=\"comment\">//String</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>不建议使用：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> width: <span class=\"type\">NSNumber</span> = <span class=\"number\">120.0</span>                                 <span class=\"comment\">//NSNumber</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> widthString: <span class=\"type\">NSString</span> = width.stringValue               <span class=\"comment\">//NSString</span></span><br></pre></td></tr></table></figure></p>\n<p>在Sprite Kit的代码中，如果<code>CGFloat</code>可以避免过多的转换从而使得代码简洁，那么请使用它。</p>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量通过<code>let</code>关键字定义，而变量使用<code>var</code>关键字定义。任何值如果<strong>是</strong>一个不变量，那么请使用<code>let</code>关键字恰如其分地定义它。最后你会发现自己喜欢使用<code>let</code>远多于<code>far</code>。</p>\n<p><strong>Tip：</strong>有一个方法可以帮你满足该项规则，将所有值都定义成常量，然后编译器提示的时候将其改为变量。</p>\n<h3 id=\"Optional\"><a href=\"#Optional\" class=\"headerlink\" title=\"Optional\"></a>Optional</h3><p>在nil值可能出现的情况下，将变量跟函数返回值的类型通过<code>?</code>定义成Optional。</p>\n<p>只有在确定实例变量会在初始化之后才被使用的情况下，通过<code>!</code>将其定义为隐式解包类型（Implicitly Unwrapped Types），比如说会在<code>viewDidLoad</code>中被创建的子视图。</p>\n<p>在访问一个Optional值时，如果该值只被访问一次，或者之后需要连续访问多个Optional值，请使用链式Optional语法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myOptional?.anotherOne?.optionalView?.setNeedsDisplay()</span><br></pre></td></tr></table></figure>\n<p>对于需要将Optional值解开一次，然后进行多个操作的情况，使用Optional绑定更为方便：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> view = <span class=\"keyword\">self</span>.optionalView &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do many things with view</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型推导\"><a href=\"#类型推导\" class=\"headerlink\" title=\"类型推导\"></a>类型推导</h3><p>Swift的编译器可以推导出变量和常量的类型。可以显式地提供类型别名（冒号后面声明的类型），不过大多数情况下这都是不必要的。</p>\n<p>保持代码紧凑，然后让编译器推断变量跟常量的类型。</p>\n<p><strong>优选：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> message = <span class=\"string\">\"Click the button\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> currentBounds = computeViewBounds()</span><br></pre></td></tr></table></figure></p>\n<p><strong>不建议使用：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> message: <span class=\"type\">String</span> = <span class=\"string\">\"Click the button\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> currentBounds: <span class=\"type\">CGRect</span> = computeViewBounds()</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意</strong>：遵循这条准则意味着使用描述性强的名称比之前更为重要了。</p>\n<h3 id=\"语法糖\"><a href=\"#语法糖\" class=\"headerlink\" title=\"语法糖\"></a>语法糖</h3><p>Prefer the shortcut versions of type declarations over the full generics syntax.</p>\n<p>使用简写的类型声明，而不是它的全泛型版本。</p>\n<p><strong>优选：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> deviceModels: [<span class=\"type\">String</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> employees: [<span class=\"type\">Int</span>: <span class=\"type\">String</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> faxNumber: <span class=\"type\">Int</span>?</span><br></pre></td></tr></table></figure></p>\n<p><strong>不建议使用：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> deviceModels: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">var</span> employees: <span class=\"type\">Dictionary</span>&lt;<span class=\"type\">Int</span>, <span class=\"type\">String</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">var</span> faxNumber: <span class=\"type\">Optional</span>&lt;<span class=\"type\">Int</span>&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h2><p>对于<code>for</code>循环，优选<code>for-in</code>风格而不是<code>for-condition-increment</code>风格：</p>\n<p><strong>优选：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;<span class=\"number\">3</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">\"Hello three times\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> person <span class=\"keyword\">in</span> attendeeList &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>不建议使用：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++ &#123;</span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">\"Hello three times\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; attendeeList.<span class=\"built_in\">count</span>; i++ &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> person = attendeeList[i]</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"笑脸\"><a href=\"#笑脸\" class=\"headerlink\" title=\"笑脸\"></a>笑脸</h2><p>笑脸对于raywenderlich.com来说是一个格外重要的风格特征。使用正确的笑脸可以表示出对某个主题的无穷尽的高兴以及兴奋程度。选用了<code>]</code>是因为它在ASCII艺术可以表示得最大的笑脸。而闭圆括号<code>)</code>因为给人一种“<strong>呵呵</strong>”的感觉而不建议使用。</p>\n<p><strong>优选：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:]</span><br></pre></td></tr></table></figure></p>\n<p><strong>不建议使用：</strong></p>\n<pre><code>:)\n</code></pre><h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>该风格指南是由下面这些格外有范儿的raywenderlich.com团队成员齐心协力一同打造：</p>\n<ul>\n<li><a href=\"https://github.com/moayes\" target=\"_blank\" rel=\"external\">Soheil Moayedi Azarpour</a></li>\n<li><a href=\"https://github.com/Scott90\" target=\"_blank\" rel=\"external\">Scott Berrevoets</a></li>\n<li><a href=\"https://github.com/ecerney\" target=\"_blank\" rel=\"external\">Eric Cerney</a></li>\n<li><a href=\"https://github.com/sammyd\" target=\"_blank\" rel=\"external\">Sam Davies</a></li>\n<li><a href=\"https://github.com/edekhayser\" target=\"_blank\" rel=\"external\">Evan Dekhayser</a></li>\n<li><a href=\"https://github.com/pdistler\" target=\"_blank\" rel=\"external\">Jean-Pierre Distler</a></li>\n<li><a href=\"https://github.com/ColinEberhardt\" target=\"_blank\" rel=\"external\">Colin Eberhardt</a></li>\n<li><a href=\"https://github.com/gregheo\" target=\"_blank\" rel=\"external\">Greg Heo</a></li>\n<li><a href=\"https://github.com/hollance\" target=\"_blank\" rel=\"external\">Matthijs Hollemans</a></li>\n<li><a href=\"https://github.com/eskerber\" target=\"_blank\" rel=\"external\">Erik Kerber</a></li>\n<li><a href=\"https://github.com/elephantronic\" target=\"_blank\" rel=\"external\">Christopher LaPollo</a></li>\n<li><a href=\"https://github.com/macandyp\" target=\"_blank\" rel=\"external\">Andy Pereira</a></li>\n<li><a href=\"https://github.com/rnystrom\" target=\"_blank\" rel=\"external\">Ryan Nystrom</a></li>\n<li><a href=\"https://github.com/funkyboy\" target=\"_blank\" rel=\"external\">Cesare Rocchi</a></li>\n<li><a href=\"https://github.com/designatednerd\" target=\"_blank\" rel=\"external\">Ellen Shapiro</a></li>\n<li><a href=\"https://github.com/icanzilb\" target=\"_blank\" rel=\"external\">Marin Todorov</a></li>\n<li><a href=\"https://github.com/cwagdev\" target=\"_blank\" rel=\"external\">Chris Wagner</a></li>\n<li><a href=\"https://github.com/rwenderlich\" target=\"_blank\" rel=\"external\">Ray Wenderlich</a></li>\n<li><a href=\"https://github.com/jackwu95\" target=\"_blank\" rel=\"external\">Jack Wu</a></li>\n</ul>\n<p>向<a href=\"https://github.com/ndubbs\" target=\"_blank\" rel=\"external\">Nicholas Waynik</a>以及<a href=\"https://github.com/raywenderlich/objective-c-style-guide\" target=\"_blank\" rel=\"external\">Objective-C风格指南</a>团队脱帽致礼！</p>\n<p>我们也从苹果公司的有关Swift的参考材料中获取了灵感：</p>\n<ul>\n<li><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/index.html\" target=\"_blank\" rel=\"external\">The Swift Programming Language</a></li>\n<li><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html\" target=\"_blank\" rel=\"external\">Using Swift with Cocoa and Objective-C</a></li>\n<li><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/General/Reference/SwiftStandardLibraryReference/index.html\" target=\"_blank\" rel=\"external\">Swift Standard Library Reference</a></li>\n</ul>\n","excerpt":"","more":"<p>因为该指南关注于网页上以及打印版的可读性，所以它可能与你阅读过的指南有所不同。为了保证那些在我们书中、教程里以及初学者工程里的代码美观并且一致，我们写下了这份风格指南，尽管书由许多不同作者共同创作而成。</p>\n<p>该指南的首要目标是让代码紧凑，可读性高且简洁。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ul>\n<li><a href=\"#语言\">语言</a></li>\n<li><a href=\"#间隔\">间隔</a></li>\n<li><a href=\"#注释\">注释</a></li>\n<li><a href=\"#命名\">命名</a><ul>\n<li><a href=\"#类前缀\">类前缀</a></li>\n</ul>\n</li>\n<li><a href=\"#分号\">分号</a></li>\n<li><a href=\"#类与结构体\">类与结构体</a></li>\n<li><a href=\"#函数声明\">函数声明</a></li>\n<li><a href=\"#闭包\">闭包</a></li>\n<li><a href=\"#类型\">类型</a><ul>\n<li><a href=\"#常量\">常量</a></li>\n<li><a href=\"#Optional\">Optional</a></li>\n<li><a href=\"#类型推导\">类型推导</a></li>\n<li><a href=\"#语法糖\">语法糖</a></li>\n</ul>\n</li>\n<li><a href=\"#控制流\">控制流</a></li>\n<li><a href=\"#Self的使用\">Self的使用</a></li>\n<li><a href=\"#笑脸\">笑脸</a></li>\n<li><a href=\"#致谢\">致谢</a></li>\n</ul>\n<h2 id=\"语言\"><a href=\"#语言\" class=\"headerlink\" title=\"语言\"></a>语言</h2><p>使用美式英语拼写以确保和苹果公司的API一致</p>\n<p><strong>优选：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> color = <span class=\"string\">\"red\"</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>不建议使用：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> colour = <span class=\"string\">\"red\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"间隔\"><a href=\"#间隔\" class=\"headerlink\" title=\"间隔\"></a>间隔</h2><ul>\n<li>使用2个空格而不是Tab进行缩进，可以减少换行。确保在Xcode的配置项中使用此设置。</li>\n<li>方法的花括号以及其它花括号（<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code>等等）总是跟语句在同一行开始，新起一行结束。</li>\n</ul>\n<p><strong>优选：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> user.isHappy &#123;</span><br><span class=\"line\">  <span class=\"comment\">//Do something</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//Do something else</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不建议使用：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> user.isHappy</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//Do something else</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法之间应该总是用一个空行进行分隔以提高视觉以及结构上的清晰度。方法中的空白用来分开功能块，但是如果一个方法中存在太多功能块时，通常意味着你需要将它重构为多个方法。</li>\n</ul>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><ul>\n<li><p>在需要的时候使用注释说明一块代码<strong>为什么</strong>这么做。注释必须时刻跟进代码，不然删了得了。</p>\n</li>\n<li><p>代码应该尽可能的自文档化，避免在代码中使用成块的注释。<strong>例外：该规则不适用与用于生成文档的块注释。</strong></p>\n</li>\n</ul>\n<h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h2><p>使用驼峰法为类、方法、变量等取一个描述性强的名字。模块范围的类名和常量名以大写字母开头，而方法名和变量名应以小写字母开头。</p>\n<p><strong>优选：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">MaximumWidgetCount</span> = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WidgetContainer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> widgetButton: <span class=\"type\">UIButton</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> widgetHeightPercentage = <span class=\"number\">0.85</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不建议使用：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"type\">MAX_WIDGET_COUNT</span> = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">app_widgetContainer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> wBut: <span class=\"type\">UIButton</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> wHeightPct = <span class=\"number\">0.85</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于函数以及初始化方法，除非上下文含义非常清楚，推荐对所有的参数都加以命名。如果外部参数名称可以使得函数调用更易读，请加上它。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dateFromString</span><span class=\"params\">(dateString: NSString)</span></span> -&gt; <span class=\"type\">NSDate</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">convertPointAt</span><span class=\"params\">(#column: Int, #row: Int)</span></span> -&gt; <span class=\"type\">CGPoint</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">timedAction</span><span class=\"params\">(#delay: NSTimeInterval, perform action: SKAction)</span></span> -&gt; <span class=\"type\">SKAction</span>!</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 会被这样调用</span></span><br><span class=\"line\">dateFromString(<span class=\"string\">\"2014-03-14\"</span>)</span><br><span class=\"line\">convertPointAt(column: <span class=\"number\">42</span>, row: <span class=\"number\">13</span>)</span><br><span class=\"line\">timedAction(delay: <span class=\"number\">1.0</span>, perform: someOtherAction)</span><br></pre></td></tr></table></figure>\n<p>对于方法，遵循苹果公司的命名规范，在方法名中提及第一个参数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Guideline</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">combineWithString</span><span class=\"params\">(incoming: String, options: Dictionary?)</span></span> &#123; ... &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">upvoteBy</span><span class=\"params\">(amount: Int)</span></span> &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在所有提及到函数的内容中（包括教程，书以及评论），请从调用者的视角进行考虑，将所有的必要参数名都包含进来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dateFromString()函数真是太棒了。</span><br><span class=\"line\">在你的init()方法中调用convertPointAt(column:, row:)。</span><br><span class=\"line\">timedAction(delay:, perform:)的返回值可能为nil。</span><br><span class=\"line\">Guideline对象只有两个方法：combineWithString(options:)和upvoteBy()。</span><br><span class=\"line\">你不应该直接调用数据源方法tableView(cellForRowAtIndexPath:)。</span><br></pre></td></tr></table></figure>\n<h3 id=\"类前缀\"><a href=\"#类前缀\" class=\"headerlink\" title=\"类前缀\"></a>类前缀</h3><p>Swift中的类型会被自动加入包含它们的模块的命名空间。所以减少命名冲突的前缀已经不必要了。如果同模块的两个名称冲突了，可以在名称前加上模块名消除歧义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> MyModule</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myClass = <span class=\"type\">MyModule</span>.<span class=\"type\">MyClass</span>()</span><br></pre></td></tr></table></figure>\n<p><strong>不应该</strong>给自己创建的Swift类型加前缀。</p>\n<p>如果需要把Swift类型暴露给Objective-C使用，你可以添加一个合适的前缀（前缀的命名请参考<a href=\"https://github.com/raywenderlich/objective-c-style-guide\">Objective-C风格指南</a>）:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@objc</span> (<span class=\"type\">RWTChicken</span>) <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chicken</span> </span>&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分号\"><a href=\"#分号\" class=\"headerlink\" title=\"分号\"></a>分号</h2><p>Swift不要求每条语句后加分号。只有在你想把多条语句写到一行时才需要加上分号。</p>\n<p>请不要在一行中写上用分号隔开的多条语句。</p>\n<p>这条规则的唯一例外就是<code>for-conditional-increment</code>结构，该结构中分号是必需的。不过请尽量用<code>for-in</code>结构代替它们。</p>\n<p><strong>优选：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> swift = <span class=\"string\">\"not a scripting language\"</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>不建议使用：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> swift = <span class=\"string\">\"not a scripting language\"</span>;</span><br></pre></td></tr></table></figure></p>\n<p><strong>请注意</strong>：Swift与JavaScript不同, 在后者中省略分号<a href=\"http://stackoverflow.com/questions/444080/do-you-recommend-using-semicolons-after-every-statement-in-javascript\">通常是不安全的</a>。</p>\n<h2 id=\"类与结构体\"><a href=\"#类与结构体\" class=\"headerlink\" title=\"类与结构体\"></a>类与结构体</h2><p>下面是一个风格良好的类定义代码例子，请参考：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span>: <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> radius: <span class=\"type\">Double</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> diameter: <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> radius * <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">      radius = newValue / <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">init</span>(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>, radius: <span class=\"type\">Double</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.x = x</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.y = y</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.radius = radius</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>, diameter: <span class=\"type\">Double</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(x: x, y: y, radius: diameter / <span class=\"number\">2</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"I am a circle at (<span class=\"subst\">\\(x)</span>,<span class=\"subst\">\\(y)</span>) with an area of <span class=\"subst\">\\(computeArea()</span>)\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">computeArea</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">M_PI</span> * radius * radius</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子阐述了如下的风格准则：</p>\n<ul>\n<li>给属性、变量、常量、参数及其它语句指定类型时，在冒号的后面加上空格而不是前面，比如：<code>x: Int</code>跟<code>Circle: Shape</code>。</li>\n<li>对getter跟setter定义以及属性观察器进行缩进。</li>\n<li>如果多个变量、结构有着同样的目的或者上下文，在同一行上进行定义。</li>\n</ul>\n<h2 id=\"Self的使用\"><a href=\"#Self的使用\" class=\"headerlink\" title=\"Self的使用\"></a>Self的使用</h2><p>在Swift中访问对象属性或调用方法时不需要使用<code>self</code>，请避免使用它。</p>\n<p>使用<code>self</code>的唯一理由是在初始化一个类或结构体时区分属性名和参数名：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoardLocation</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> row: <span class=\"type\">Int</span>, column: <span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">init</span>(row: <span class=\"type\">Int</span>,column: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.row = row</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.column = column</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h2><p>保持函数声明短小精悍，保持在一行内，花括号在同一行内开始：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reticulateSplines</span><span class=\"params\">(spline: [Double])</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// reticulate code goes here</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于有着长签名的函数，请在适当的位置进行断行且对后续行缩进一级：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reticulateSplines</span><span class=\"params\">(spline: [Double], adjustmentFactor: Double,</span><br><span class=\"line\">    translateConstant: Int, comment: String)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// reticulate code goes here</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>尽可能地使用尾闭包语法。在所有的情况下给闭包参数一个描述性强的名称：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"type\">SKAction</span>.customActionWithDuration(effect.duration) &#123; node, elapsedTime <span class=\"keyword\">in</span> </span><br><span class=\"line\">  <span class=\"comment\">// more code goes here</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于上下文清晰的单表达式闭包，使用隐式的返回值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attendeeList.<span class=\"built_in\">sort</span> &#123; a, b <span class=\"keyword\">in</span></span><br><span class=\"line\">  a &gt; b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><p>如果可能，使用Swift的原生类型。Swift提供了对Objective-C的桥接，如果需要，仍然可以使用全部的Objective-C方法：</p>\n<p><strong>优选：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> width = <span class=\"number\">120.0</span>                                           <span class=\"comment\">//Double</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> widthString = width.<span class=\"built_in\">bridgeToObjectiveC</span>().stringValue    <span class=\"comment\">//String</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>不建议使用：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> width: <span class=\"type\">NSNumber</span> = <span class=\"number\">120.0</span>                                 <span class=\"comment\">//NSNumber</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> widthString: <span class=\"type\">NSString</span> = width.stringValue               <span class=\"comment\">//NSString</span></span><br></pre></td></tr></table></figure></p>\n<p>在Sprite Kit的代码中，如果<code>CGFloat</code>可以避免过多的转换从而使得代码简洁，那么请使用它。</p>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量通过<code>let</code>关键字定义，而变量使用<code>var</code>关键字定义。任何值如果<strong>是</strong>一个不变量，那么请使用<code>let</code>关键字恰如其分地定义它。最后你会发现自己喜欢使用<code>let</code>远多于<code>far</code>。</p>\n<p><strong>Tip：</strong>有一个方法可以帮你满足该项规则，将所有值都定义成常量，然后编译器提示的时候将其改为变量。</p>\n<h3 id=\"Optional\"><a href=\"#Optional\" class=\"headerlink\" title=\"Optional\"></a>Optional</h3><p>在nil值可能出现的情况下，将变量跟函数返回值的类型通过<code>?</code>定义成Optional。</p>\n<p>只有在确定实例变量会在初始化之后才被使用的情况下，通过<code>!</code>将其定义为隐式解包类型（Implicitly Unwrapped Types），比如说会在<code>viewDidLoad</code>中被创建的子视图。</p>\n<p>在访问一个Optional值时，如果该值只被访问一次，或者之后需要连续访问多个Optional值，请使用链式Optional语法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myOptional?.anotherOne?.optionalView?.setNeedsDisplay()</span><br></pre></td></tr></table></figure>\n<p>对于需要将Optional值解开一次，然后进行多个操作的情况，使用Optional绑定更为方便：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> view = <span class=\"keyword\">self</span>.optionalView &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do many things with view</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型推导\"><a href=\"#类型推导\" class=\"headerlink\" title=\"类型推导\"></a>类型推导</h3><p>Swift的编译器可以推导出变量和常量的类型。可以显式地提供类型别名（冒号后面声明的类型），不过大多数情况下这都是不必要的。</p>\n<p>保持代码紧凑，然后让编译器推断变量跟常量的类型。</p>\n<p><strong>优选：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> message = <span class=\"string\">\"Click the button\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> currentBounds = computeViewBounds()</span><br></pre></td></tr></table></figure></p>\n<p><strong>不建议使用：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> message: <span class=\"type\">String</span> = <span class=\"string\">\"Click the button\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> currentBounds: <span class=\"type\">CGRect</span> = computeViewBounds()</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意</strong>：遵循这条准则意味着使用描述性强的名称比之前更为重要了。</p>\n<h3 id=\"语法糖\"><a href=\"#语法糖\" class=\"headerlink\" title=\"语法糖\"></a>语法糖</h3><p>Prefer the shortcut versions of type declarations over the full generics syntax.</p>\n<p>使用简写的类型声明，而不是它的全泛型版本。</p>\n<p><strong>优选：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> deviceModels: [<span class=\"type\">String</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> employees: [<span class=\"type\">Int</span>: <span class=\"type\">String</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> faxNumber: <span class=\"type\">Int</span>?</span><br></pre></td></tr></table></figure></p>\n<p><strong>不建议使用：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> deviceModels: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">var</span> employees: <span class=\"type\">Dictionary</span>&lt;<span class=\"type\">Int</span>, <span class=\"type\">String</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">var</span> faxNumber: <span class=\"type\">Optional</span>&lt;<span class=\"type\">Int</span>&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h2><p>对于<code>for</code>循环，优选<code>for-in</code>风格而不是<code>for-condition-increment</code>风格：</p>\n<p><strong>优选：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;<span class=\"number\">3</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">\"Hello three times\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> person <span class=\"keyword\">in</span> attendeeList &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>不建议使用：</strong><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++ &#123;</span><br><span class=\"line\">  <span class=\"built_in\">println</span>(<span class=\"string\">\"Hello three times\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; attendeeList.<span class=\"built_in\">count</span>; i++ &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> person = attendeeList[i]</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"笑脸\"><a href=\"#笑脸\" class=\"headerlink\" title=\"笑脸\"></a>笑脸</h2><p>笑脸对于raywenderlich.com来说是一个格外重要的风格特征。使用正确的笑脸可以表示出对某个主题的无穷尽的高兴以及兴奋程度。选用了<code>]</code>是因为它在ASCII艺术可以表示得最大的笑脸。而闭圆括号<code>)</code>因为给人一种“<strong>呵呵</strong>”的感觉而不建议使用。</p>\n<p><strong>优选：</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:]</span><br></pre></td></tr></table></figure></p>\n<p><strong>不建议使用：</strong></p>\n<pre><code>:)\n</code></pre><h2 id=\"致谢\"><a href=\"#致谢\" class=\"headerlink\" title=\"致谢\"></a>致谢</h2><p>该风格指南是由下面这些格外有范儿的raywenderlich.com团队成员齐心协力一同打造：</p>\n<ul>\n<li><a href=\"https://github.com/moayes\">Soheil Moayedi Azarpour</a></li>\n<li><a href=\"https://github.com/Scott90\">Scott Berrevoets</a></li>\n<li><a href=\"https://github.com/ecerney\">Eric Cerney</a></li>\n<li><a href=\"https://github.com/sammyd\">Sam Davies</a></li>\n<li><a href=\"https://github.com/edekhayser\">Evan Dekhayser</a></li>\n<li><a href=\"https://github.com/pdistler\">Jean-Pierre Distler</a></li>\n<li><a href=\"https://github.com/ColinEberhardt\">Colin Eberhardt</a></li>\n<li><a href=\"https://github.com/gregheo\">Greg Heo</a></li>\n<li><a href=\"https://github.com/hollance\">Matthijs Hollemans</a></li>\n<li><a href=\"https://github.com/eskerber\">Erik Kerber</a></li>\n<li><a href=\"https://github.com/elephantronic\">Christopher LaPollo</a></li>\n<li><a href=\"https://github.com/macandyp\">Andy Pereira</a></li>\n<li><a href=\"https://github.com/rnystrom\">Ryan Nystrom</a></li>\n<li><a href=\"https://github.com/funkyboy\">Cesare Rocchi</a></li>\n<li><a href=\"https://github.com/designatednerd\">Ellen Shapiro</a></li>\n<li><a href=\"https://github.com/icanzilb\">Marin Todorov</a></li>\n<li><a href=\"https://github.com/cwagdev\">Chris Wagner</a></li>\n<li><a href=\"https://github.com/rwenderlich\">Ray Wenderlich</a></li>\n<li><a href=\"https://github.com/jackwu95\">Jack Wu</a></li>\n</ul>\n<p>向<a href=\"https://github.com/ndubbs\">Nicholas Waynik</a>以及<a href=\"https://github.com/raywenderlich/objective-c-style-guide\">Objective-C风格指南</a>团队脱帽致礼！</p>\n<p>我们也从苹果公司的有关Swift的参考材料中获取了灵感：</p>\n<ul>\n<li><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/index.html\">The Swift Programming Language</a></li>\n<li><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html\">Using Swift with Cocoa and Objective-C</a></li>\n<li><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/General/Reference/SwiftStandardLibraryReference/index.html\">Swift Standard Library Reference</a></li>\n</ul>\n"},{"layout":"post","title":"一个更具包容性的经济发展蓝图","date":"2016-03-06T10:44:17.000Z","comments":1,"_content":"\n\n哈佛商学院校友最近的一项调查发现，71%的受访者认为他们的生意受到了`不平等`，`中产阶级的停滞`，`日益增长的贫困`，或`有限的经济流动`的伤害。66%的受访者认为解决这些问题比促进经济发展重要。\n\n尽管如此，许多雇主仍然觉得采取诸如改善工人和家庭的福祉的行动，是别人的工作。\n\n这种心态是一个错误。商界领袖不只是雇主：作为区域经济发展实体的董事会成员，他们在城市和大都会地区的城市，他们的公司有重大影响。随着政府和非营利部门的合作伙伴，他们有能力转变和扩大经济发展的目的和实践。\n\n在最近的一篇文章中，我提出了一个改善经济发展的框架，我认为，可持续的区域增长需要提高所有的生活水平。经济的包容性必须是经济决策者和企业的优先考虑。如果下一代的工人不准备满足主要雇主的需求，那将扼杀行业的生产力、扩张和剩余价值。如果人们失业或半失业，他们不能购买许多商品和服务的生产，伤害小企业和企业家。低效利用土地和基础设施-包括拥塞可以创造阻碍工作访问，限制了生产率的提高，和损害财产。\n\n认识到促进经济包容的必要性是一件事，但做这件事是另一回事。在整个国家，一些企业和公民领袖正在为如何实现更具包容性的增长提供一个蓝图。这里有三个概念已经出现：\n\n### 确立一个明确的目标，并评估它\n\n促进经济包容性是以达成目标一致的。在`明尼阿波利斯-圣保罗`，不同的利益相关者从经济发展，慈善事业，企业，政府和社区的发展，共同达成共识，对经济，社会和环境的进步，这将引导他们的区域战略的50多个指标。确立一个基本目标后，他们解决了一个核心组合的指标来衡量创新，人才开发，就业准入，和工作质量，同时越来越多的关注基于种族的贫困与不平等。新的区域性仪表板包括指标，如“16至64岁的外国人口占总劳动人口百分比”和“白种人与其它种族人的就业差异”，如果各地区的利益相关者没能在一个地区达成一致的集体目标，并设法实现，则建设包容性经济将无从谈起。\n\n### 重点支持能提供良好的就业机会的行业\n\n不是所有的工作都是平等的。在美国每四个成年人，几乎就有一个人的工资难以维持正常生活，而国民经济中的低收入工作岗位却越来越多。根据国家就业法项目的报告，230万以上的工人受雇于低工资行业，而不是经济衰退的开始，而在中等收入和高工资行业就业的则少了120万。所有群体的经济活动开始于就业，它能使一个工人脱离贫困，做不到这样就无法减少种族差异、提高经济流动性。为提高包容性，领导者必须优先支持那些能提供较高人均收入、能维持家庭的工作岗位的产业。\n","source":"_posts/2016-03-06-[?]-ge-geng-ju-bao-rong-xing-de-jing-ji-fa-zhan-lan-tu.markdown","raw":"---\nlayout: post\ntitle: \"一个更具包容性的经济发展蓝图\"\ndate: 2016-03-06 18:44:17 +0800\ncomments: true\ncategories: 翻译\n---\n\n\n哈佛商学院校友最近的一项调查发现，71%的受访者认为他们的生意受到了`不平等`，`中产阶级的停滞`，`日益增长的贫困`，或`有限的经济流动`的伤害。66%的受访者认为解决这些问题比促进经济发展重要。\n\n尽管如此，许多雇主仍然觉得采取诸如改善工人和家庭的福祉的行动，是别人的工作。\n\n这种心态是一个错误。商界领袖不只是雇主：作为区域经济发展实体的董事会成员，他们在城市和大都会地区的城市，他们的公司有重大影响。随着政府和非营利部门的合作伙伴，他们有能力转变和扩大经济发展的目的和实践。\n\n在最近的一篇文章中，我提出了一个改善经济发展的框架，我认为，可持续的区域增长需要提高所有的生活水平。经济的包容性必须是经济决策者和企业的优先考虑。如果下一代的工人不准备满足主要雇主的需求，那将扼杀行业的生产力、扩张和剩余价值。如果人们失业或半失业，他们不能购买许多商品和服务的生产，伤害小企业和企业家。低效利用土地和基础设施-包括拥塞可以创造阻碍工作访问，限制了生产率的提高，和损害财产。\n\n认识到促进经济包容的必要性是一件事，但做这件事是另一回事。在整个国家，一些企业和公民领袖正在为如何实现更具包容性的增长提供一个蓝图。这里有三个概念已经出现：\n\n### 确立一个明确的目标，并评估它\n\n促进经济包容性是以达成目标一致的。在`明尼阿波利斯-圣保罗`，不同的利益相关者从经济发展，慈善事业，企业，政府和社区的发展，共同达成共识，对经济，社会和环境的进步，这将引导他们的区域战略的50多个指标。确立一个基本目标后，他们解决了一个核心组合的指标来衡量创新，人才开发，就业准入，和工作质量，同时越来越多的关注基于种族的贫困与不平等。新的区域性仪表板包括指标，如“16至64岁的外国人口占总劳动人口百分比”和“白种人与其它种族人的就业差异”，如果各地区的利益相关者没能在一个地区达成一致的集体目标，并设法实现，则建设包容性经济将无从谈起。\n\n### 重点支持能提供良好的就业机会的行业\n\n不是所有的工作都是平等的。在美国每四个成年人，几乎就有一个人的工资难以维持正常生活，而国民经济中的低收入工作岗位却越来越多。根据国家就业法项目的报告，230万以上的工人受雇于低工资行业，而不是经济衰退的开始，而在中等收入和高工资行业就业的则少了120万。所有群体的经济活动开始于就业，它能使一个工人脱离贫困，做不到这样就无法减少种族差异、提高经济流动性。为提高包容性，领导者必须优先支持那些能提供较高人均收入、能维持家庭的工作岗位的产业。\n","slug":"2016-03-06-[?]-ge-geng-ju-bao-rong-xing-de-jing-ji-fa-zhan-lan-tu","published":1,"updated":"2016-03-06T10:48:03.000Z","photos":[],"link":"","_id":"cimohsgps0006sqphuls62rrf","content":"<p>哈佛商学院校友最近的一项调查发现，71%的受访者认为他们的生意受到了<code>不平等</code>，<code>中产阶级的停滞</code>，<code>日益增长的贫困</code>，或<code>有限的经济流动</code>的伤害。66%的受访者认为解决这些问题比促进经济发展重要。</p>\n<p>尽管如此，许多雇主仍然觉得采取诸如改善工人和家庭的福祉的行动，是别人的工作。</p>\n<p>这种心态是一个错误。商界领袖不只是雇主：作为区域经济发展实体的董事会成员，他们在城市和大都会地区的城市，他们的公司有重大影响。随着政府和非营利部门的合作伙伴，他们有能力转变和扩大经济发展的目的和实践。</p>\n<p>在最近的一篇文章中，我提出了一个改善经济发展的框架，我认为，可持续的区域增长需要提高所有的生活水平。经济的包容性必须是经济决策者和企业的优先考虑。如果下一代的工人不准备满足主要雇主的需求，那将扼杀行业的生产力、扩张和剩余价值。如果人们失业或半失业，他们不能购买许多商品和服务的生产，伤害小企业和企业家。低效利用土地和基础设施-包括拥塞可以创造阻碍工作访问，限制了生产率的提高，和损害财产。</p>\n<p>认识到促进经济包容的必要性是一件事，但做这件事是另一回事。在整个国家，一些企业和公民领袖正在为如何实现更具包容性的增长提供一个蓝图。这里有三个概念已经出现：</p>\n<h3 id=\"确立一个明确的目标，并评估它\"><a href=\"#确立一个明确的目标，并评估它\" class=\"headerlink\" title=\"确立一个明确的目标，并评估它\"></a>确立一个明确的目标，并评估它</h3><p>促进经济包容性是以达成目标一致的。在<code>明尼阿波利斯-圣保罗</code>，不同的利益相关者从经济发展，慈善事业，企业，政府和社区的发展，共同达成共识，对经济，社会和环境的进步，这将引导他们的区域战略的50多个指标。确立一个基本目标后，他们解决了一个核心组合的指标来衡量创新，人才开发，就业准入，和工作质量，同时越来越多的关注基于种族的贫困与不平等。新的区域性仪表板包括指标，如“16至64岁的外国人口占总劳动人口百分比”和“白种人与其它种族人的就业差异”，如果各地区的利益相关者没能在一个地区达成一致的集体目标，并设法实现，则建设包容性经济将无从谈起。</p>\n<h3 id=\"重点支持能提供良好的就业机会的行业\"><a href=\"#重点支持能提供良好的就业机会的行业\" class=\"headerlink\" title=\"重点支持能提供良好的就业机会的行业\"></a>重点支持能提供良好的就业机会的行业</h3><p>不是所有的工作都是平等的。在美国每四个成年人，几乎就有一个人的工资难以维持正常生活，而国民经济中的低收入工作岗位却越来越多。根据国家就业法项目的报告，230万以上的工人受雇于低工资行业，而不是经济衰退的开始，而在中等收入和高工资行业就业的则少了120万。所有群体的经济活动开始于就业，它能使一个工人脱离贫困，做不到这样就无法减少种族差异、提高经济流动性。为提高包容性，领导者必须优先支持那些能提供较高人均收入、能维持家庭的工作岗位的产业。</p>\n","excerpt":"","more":"<p>哈佛商学院校友最近的一项调查发现，71%的受访者认为他们的生意受到了<code>不平等</code>，<code>中产阶级的停滞</code>，<code>日益增长的贫困</code>，或<code>有限的经济流动</code>的伤害。66%的受访者认为解决这些问题比促进经济发展重要。</p>\n<p>尽管如此，许多雇主仍然觉得采取诸如改善工人和家庭的福祉的行动，是别人的工作。</p>\n<p>这种心态是一个错误。商界领袖不只是雇主：作为区域经济发展实体的董事会成员，他们在城市和大都会地区的城市，他们的公司有重大影响。随着政府和非营利部门的合作伙伴，他们有能力转变和扩大经济发展的目的和实践。</p>\n<p>在最近的一篇文章中，我提出了一个改善经济发展的框架，我认为，可持续的区域增长需要提高所有的生活水平。经济的包容性必须是经济决策者和企业的优先考虑。如果下一代的工人不准备满足主要雇主的需求，那将扼杀行业的生产力、扩张和剩余价值。如果人们失业或半失业，他们不能购买许多商品和服务的生产，伤害小企业和企业家。低效利用土地和基础设施-包括拥塞可以创造阻碍工作访问，限制了生产率的提高，和损害财产。</p>\n<p>认识到促进经济包容的必要性是一件事，但做这件事是另一回事。在整个国家，一些企业和公民领袖正在为如何实现更具包容性的增长提供一个蓝图。这里有三个概念已经出现：</p>\n<h3 id=\"确立一个明确的目标，并评估它\"><a href=\"#确立一个明确的目标，并评估它\" class=\"headerlink\" title=\"确立一个明确的目标，并评估它\"></a>确立一个明确的目标，并评估它</h3><p>促进经济包容性是以达成目标一致的。在<code>明尼阿波利斯-圣保罗</code>，不同的利益相关者从经济发展，慈善事业，企业，政府和社区的发展，共同达成共识，对经济，社会和环境的进步，这将引导他们的区域战略的50多个指标。确立一个基本目标后，他们解决了一个核心组合的指标来衡量创新，人才开发，就业准入，和工作质量，同时越来越多的关注基于种族的贫困与不平等。新的区域性仪表板包括指标，如“16至64岁的外国人口占总劳动人口百分比”和“白种人与其它种族人的就业差异”，如果各地区的利益相关者没能在一个地区达成一致的集体目标，并设法实现，则建设包容性经济将无从谈起。</p>\n<h3 id=\"重点支持能提供良好的就业机会的行业\"><a href=\"#重点支持能提供良好的就业机会的行业\" class=\"headerlink\" title=\"重点支持能提供良好的就业机会的行业\"></a>重点支持能提供良好的就业机会的行业</h3><p>不是所有的工作都是平等的。在美国每四个成年人，几乎就有一个人的工资难以维持正常生活，而国民经济中的低收入工作岗位却越来越多。根据国家就业法项目的报告，230万以上的工人受雇于低工资行业，而不是经济衰退的开始，而在中等收入和高工资行业就业的则少了120万。所有群体的经济活动开始于就业，它能使一个工人脱离贫困，做不到这样就无法减少种族差异、提高经济流动性。为提高包容性，领导者必须优先支持那些能提供较高人均收入、能维持家庭的工作岗位的产业。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cimohsgp80000sqph9guirsqp","category_id":"cimohsgph0002sqph5k3duqlr","_id":"cimohsgpt0007sqphx2taejvk"},{"post_id":"cimohsgps0006sqphuls62rrf","category_id":"cimohsgpu0008sqphcleuyx8q","_id":"cimohsgpu0009sqphva5sanf6"}],"PostTag":[],"Tag":[]}}